--- glibc/ChangeLog
+++ riscv-glibc/ChangeLog
@@ -1,24 +1,3 @@
-2016-08-04  Carlos O'Donell  <carlos@redhat.com>
-
-	* po/de.po: Update from Translation Project.
-	* po/fi.po: Likewise.
-	* po/sv.po: Likewise.
-
-2016-08-02  Florian Weimer  <fweimer@redhat.com>
-
-	[BZ #20370]
-	* malloc/arena.c (get_free_list): Update comment.  Assert that
-	arenas on the free list have no attached threads.
-	(remove_from_free_list): New function.
-	(reused_arena): Call it.
-
-2016-08-04  Florian Weimer  <fweimer@redhat.com>
-
-	Use sysdep.o from libc.a in static libraries.
-	* sysdeps/unix/sysv/linux/i386/Makefile
-	(libpthread-shared-only-routines): Add sysdep.
-	(librt-shared-only-routines): Likewise.
-
 2016-08-01  Carlos O'Donell  <carlos@redhat.com>
 
 	* version.h (RELEASE): Set to "stable"
--- glibc/malloc/arena.c
+++ riscv-glibc/malloc/arena.c
@@ -702,7 +702,8 @@ _int_new_arena (size_t size)
 }
 
 
-/* Remove an arena from free_list.  */
+/* Remove an arena from free_list.  The arena may be in use because it
+   was attached concurrently to a thread by reused_arena below.  */
 static mstate
 get_free_list (void)
 {
@@ -717,8 +718,7 @@ get_free_list (void)
 	  free_list = result->next_free;
 
 	  /* The arena will be attached to this thread.  */
-	  assert (result->attached_threads == 0);
-	  result->attached_threads = 1;
+	  ++result->attached_threads;
 
 	  detach_arena (replaced_arena);
 	}
@@ -735,26 +735,6 @@ get_free_list (void)
   return result;
 }
 
-/* Remove the arena from the free list (if it is present).
-   free_list_lock must have been acquired by the caller.  */
-static void
-remove_from_free_list (mstate arena)
-{
-  mstate *previous = &free_list;
-  for (mstate p = free_list; p != NULL; p = p->next_free)
-    {
-      assert (p->attached_threads == 0);
-      if (p == arena)
-	{
-	  /* Remove the requested arena from the list.  */
-	  *previous = p->next_free;
-	  break;
-	}
-      else
-	previous = &p->next_free;
-    }
-}
-
 /* Lock and return an arena that can be reused for memory allocation.
    Avoid AVOID_ARENA as we have already failed to allocate memory in
    it and it is currently locked.  */
@@ -802,25 +782,14 @@ reused_arena (mstate avoid_arena)
   (void) mutex_lock (&result->mutex);
 
 out:
-  /* Attach the arena to the current thread.  */
+  /* Attach the arena to the current thread.  Note that we may have
+     selected an arena which was on free_list.  */
   {
     /* Update the arena thread attachment counters.   */
     mstate replaced_arena = thread_arena;
     (void) mutex_lock (&free_list_lock);
     detach_arena (replaced_arena);
-
-    /* We may have picked up an arena on the free list.  We need to
-       preserve the invariant that no arena on the free list has a
-       positive attached_threads counter (otherwise,
-       arena_thread_freeres cannot use the counter to determine if the
-       arena needs to be put on the free list).  We unconditionally
-       remove the selected arena from the free list.  The caller of
-       reused_arena checked the free list and observed it to be empty,
-       so the list is very short.  */
-    remove_from_free_list (result);
-
     ++result->attached_threads;
-
     (void) mutex_unlock (&free_list_lock);
   }
 
--- glibc/po/de.po
+++ riscv-glibc/po/de.po
@@ -8,7 +8,7 @@ msgid ""
 msgstr ""
 "Project-Id-Version: GNU libc 2.22-pre1\n"
 "POT-Creation-Date: 2015-07-31 00:10-0400\n"
-"PO-Revision-Date: 2016-04-22 18:44+0200\n"
+"PO-Revision-Date: 2015-08-31 18:30+0200\n"
 "Last-Translator: Jochen Hein <jochen@jochen.org>\n"
 "Language-Team: German <translation-team-de@lists.sourceforge.net>\n"
 "Language: de\n"
@@ -4479,13 +4479,13 @@ msgstr ""
 "%15s  Cache ist dauerhaft\n"
 "%15s  Cache wird gemeinsam verwendet\n"
 "%15Zu  vorgeschlagene Größe\n"
-"%15Zu  Gesamtgröße des Data-Pools\n"
+"%15Zu  Gesamtröße des Data-Pools\n"
 "%15Zu  Benutzter Speicher im Data-Pool\n"
 "%15lu  Time to Live für positive Einträge in Sekunden\n"
 "%15lu  Time to Live für negative Einträge in Sekunden\n"
 "%15<PRIuMAX>  Cache-Hits bei positiven Einträgen\n"
 "%15<PRIuMAX>  Cache-Hits bei positiven Einträgen\n"
-"%15<PRIuMAX>  Cache-Misses bei positiven Einträgen\n"
+"%15<PRIuMAX>  Cache-Misses bei positiven EintrÃ¤gen\n"
 "%15<PRIuMAX>  Cache-Misses bei negativen Einträgen\n"
 "%15lu%% Cache-Hit Verhältnis\n"
 "%15zu  aktuelle Anzahl der Werte im Cache\n"
--- glibc/po/fi.po
+++ riscv-glibc/po/fi.po
@@ -24,16 +24,16 @@
 #
 msgid ""
 msgstr ""
-"Project-Id-Version: libc 2.22-pre1\n"
+"Project-Id-Version: libc 2.21-pre1\n"
 "POT-Creation-Date: 2015-07-31 00:10-0400\n"
-"PO-Revision-Date: 2016-05-26 21:14+0300\n"
+"PO-Revision-Date: 2015-07-28 20:29+0300\n"
 "Last-Translator: Lauri Nurmi <lanurmi@iki.fi>\n"
 "Language-Team: Finnish <translation-team-fi@lists.sourceforge.net>\n"
 "Language: fi\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
-"X-Generator: Poedit 1.8.7\n"
+"X-Generator: Poedit 1.8.3\n"
 "Plural-Forms: nplurals=2; plural=(n != 1);\n"
 
 #: argp/argp-help.c:227
@@ -126,7 +126,7 @@ msgid "%s%s%s:%u: %s%sUnexpected error:
 msgstr "%s%s%s:%u: %s%sOdottamaton virhe: %s.\n"
 
 #: assert/assert.c:101
-#, c-format
+#, fuzzy, c-format
 msgid ""
 "%s%s%s:%u: %s%sAssertion `%s' failed.\n"
 "%n"
@@ -169,12 +169,12 @@ msgstr ""
 #: malloc/memusagestat.c:563 nss/getent.c:973 nss/makedb.c:369
 #: posix/getconf.c:486 sunrpc/rpcinfo.c:691
 #: sysdeps/unix/sysv/linux/lddlibc4.c:61
-#, c-format
+#, fuzzy, c-format
 msgid ""
 "For bug reporting instructions, please see:\n"
 "%s.\n"
 msgstr ""
-"Katso ohjeet vikailmoitusten tekemiseen osoitteesta:\n"
+"Ohjeet ohjelmistovioista ilmoittamiseen ovat osoitteessa\n"
 "%s.\n"
 
 #: catgets/gencat.c:245 debug/pcprofiledump.c:225 debug/xtrace.sh:64
@@ -321,8 +321,9 @@ msgstr "Käyttö: xtrace [VALITSIN]... O
 
 #: debug/xtrace.sh:32 elf/sotruss.sh:56 elf/sotruss.sh:67 elf/sotruss.sh:135
 #: malloc/memusage.sh:26
+#, fuzzy
 msgid "Try \\`%s --help' or \\`%s --usage' for more information.\\n"
-msgstr "Kokeile ”%s --help” tai ”%s --usage” saadaksesi lisää tietoa.\\n"
+msgstr "Kokeile ”%s --help” tai ”%s --usage” saadaksesi lisää tietoa.\n"
 
 #: debug/xtrace.sh:38
 #, fuzzy
@@ -593,8 +594,9 @@ msgid "cannot enable executable stack as
 msgstr "jaettua objektikahvaa ei voi luoda"
 
 #: elf/dl-load.c:1339
+#, fuzzy
 msgid "cannot close file descriptor"
-msgstr "tiedostokahvaa ei voi sulkea"
+msgstr "tiedostoa %s ei voi sulkea"
 
 #: elf/dl-load.c:1568
 msgid "file too short"
@@ -794,8 +796,9 @@ msgid "Format to use: new, old or compat
 msgstr "Käytettävä muoto: ”new”, ”old” tai ”compat” (oletus)"
 
 #: elf/ldconfig.c:151
+#, fuzzy
 msgid "Ignore auxiliary cache file"
-msgstr "Jätä huomiotta apuvälimuistitiedosto"
+msgstr "Käytä CACHEa välimuistitiedostona"
 
 #: elf/ldconfig.c:159
 msgid "Configure Dynamic Linker Run Time Bindings."
@@ -1084,9 +1087,9 @@ msgid "invalid process ID '%s'"
 msgstr "virheellinen prosessi-ID ”%s”"
 
 #: elf/pldd.c:120
-#, c-format
+#, fuzzy, c-format
 msgid "cannot open %s"
-msgstr "tiedostoa %s ei voi avata"
+msgstr "laitetta %s ei voi avata"
 
 #: elf/pldd.c:152
 #, fuzzy, c-format
@@ -1099,24 +1102,24 @@ msgid "cannot prepare reading %s/task"
 msgstr "ei voi avata laitetta %s lukutilaan"
 
 #: elf/pldd.c:168
-#, c-format
+#, fuzzy, c-format
 msgid "invalid thread ID '%s'"
-msgstr "virheellinen säie-ID ”%s”"
+msgstr "virheellinen prosessi-ID ”%s”"
 
 #: elf/pldd.c:179
-#, c-format
+#, fuzzy, c-format
 msgid "cannot attach to process %lu"
-msgstr "ei voida kiinnittyä prosessiin %lu"
+msgstr "tiedostoa ”%s” ei voi avata"
 
 #: elf/pldd.c:294
 #, c-format
 msgid "cannot get information about process %lu"
-msgstr "tietojen saaminen prosessista %lu ei onnistu"
+msgstr ""
 
 #: elf/pldd.c:307
-#, c-format
+#, fuzzy, c-format
 msgid "process %lu is no ELF program"
-msgstr "prosessi %lu ei ole ELF-ohjelma"
+msgstr "ohjelma %lu ei ole käytettävissä\n"
 
 #: elf/readelflib.c:34
 #, c-format
@@ -1200,7 +1203,7 @@ msgstr "%s kohde ei saa olla hakemisto\n
 #: elf/sln.c:184
 #, c-format
 msgid "%s: failed to remove the old destination\n"
-msgstr "%s: vanhan kohteen poistaminen epäonnistui\n"
+msgstr ""
 
 #: elf/sln.c:192
 #, c-format
@@ -1234,8 +1237,9 @@ msgid "Mandatory arguments to long optio
 msgstr "Pakolliset argumentit pitkille valitsimille ovat pakollisia kaikille vastaaville lyhyille valitsimille.\\n"
 
 #: elf/sotruss.sh:55
+#, fuzzy
 msgid "%s: option requires an argument -- '%s'\\n"
-msgstr "%s: valitsin vaatii argumentin -- ”%c”\\n"
+msgstr "%s: valitsin ”%s” vaatii argumentin\n"
 
 #: elf/sotruss.sh:61
 msgid "%s: option is ambiguous; possibilities:"
@@ -1503,6 +1507,7 @@ msgid "unknown iconv() error %d"
 msgstr "tuntematon iconv()-virhe %d"
 
 #: iconv/iconv_prog.c:791
+#, fuzzy
 msgid ""
 "The following list contains all the coded character sets known.  This does\n"
 "not necessarily mean that all combinations of these names can be used for\n"
@@ -1511,9 +1516,9 @@ msgid ""
 "\n"
 "  "
 msgstr ""
-"Seuraavassa listassa ovat kaikki tunnetut koodatut merkistöt. Tämä ei\n"
+"Seuraavassa listassa ovat kaikki tunnetut koodatut merkistöt. Se ei\n"
 "kuitenkaan välttämättä tarkoita sitä, että kaikkia näiden nimien\n"
-"yhdistelmiä voisi käyttää FROM- ja TO-komentoriviparametreina. Yksi\n"
+"yhdistelmiä voidaan käyttää FROM- ja TO-komentoriviparametreina. Yksi\n"
 "koodattu merkistö voi olla listalla useilla eri nimillä (aliaksilla).\n"
 "\n"
 "  "
@@ -2728,12 +2733,14 @@ msgid "locale.alias file to consult when
 msgstr "Arkistoa luotaessa käytettävä locale.alias-tiedosto"
 
 #: locale/programs/localedef.c:150
+#, fuzzy
 msgid "Generate little-endian output"
-msgstr "Tuota little-endian-muotoa"
+msgstr "Tuota little-endian-koodia"
 
 #: locale/programs/localedef.c:152
+#, fuzzy
 msgid "Generate big-endian output"
-msgstr "Tuota big-endian-muotoa"
+msgstr "Tuota big-endian-koodia"
 
 #: locale/programs/localedef.c:157
 msgid "Compile locale specification"
@@ -4268,9 +4275,10 @@ msgid ""
 msgstr ""
 
 #: nscd/nscd.c:635
-#, c-format
+#, fuzzy, c-format
+#| msgid "lstat failed"
 msgid "'wait' failed\n"
-msgstr "”wait” epäonnistui\n"
+msgstr "tiedoston tilan luku epäonnistui"
 
 #: nscd/nscd.c:642
 #, c-format
@@ -4662,9 +4670,9 @@ msgid "cannot create temporary file"
 msgstr "tilapäistä tiedostoa ei voi luoda"
 
 #: nss/makedb.c:304
-#, c-format
+#, fuzzy, c-format
 msgid "cannot stat newly created file"
-msgstr "juuri luodun tiedoston tilaa ei voi lukea"
+msgstr "tiedoston ”%s” tilaa ei voi lukea: %s"
 
 #: nss/makedb.c:315
 #, c-format
@@ -4672,9 +4680,9 @@ msgid "cannot rename temporary file"
 msgstr "tilapäistä tiedostoa ei voi nimetä uudelleen"
 
 #: nss/makedb.c:531 nss/makedb.c:554
-#, c-format
+#, fuzzy, c-format
 msgid "cannot create search tree"
-msgstr "hakupuuta ei voi luoda"
+msgstr "hakupolulle ei voi luoda välimuistia"
 
 #: nss/makedb.c:560
 msgid "duplicate key"
@@ -4691,9 +4699,9 @@ msgid "failed to write new database file
 msgstr "uuden tietokantatiedoston kirjoittaminen epäonnistui"
 
 #: nss/makedb.c:812
-#, c-format
+#, fuzzy, c-format
 msgid "cannot stat database file"
-msgstr "tietokantatiedoston tilaa ei voi lukea"
+msgstr "tiedoston ”%s” tilaa ei voi lukea: %s"
 
 #: nss/makedb.c:817
 #, fuzzy, c-format
@@ -4701,9 +4709,9 @@ msgid "cannot map database file"
 msgstr "Karttatietokannassa ei ole enempää tietueita"
 
 #: nss/makedb.c:820
-#, c-format
+#, fuzzy, c-format
 msgid "file not a database file"
-msgstr "tiedosto ei ole tietokantatiedosto"
+msgstr "luettaessa profilointidatatiedoston tilaa"
 
 #: nss/makedb.c:871
 #, fuzzy, c-format
@@ -4718,7 +4726,7 @@ msgstr "Käyttö: %s [-v määrittely] m
 #: posix/getconf.c:403
 #, c-format
 msgid "       %s -a [pathname]\n"
-msgstr "       %s -a [polku]\n"
+msgstr ""
 
 #: posix/getconf.c:479
 #, c-format
@@ -5086,11 +5094,11 @@ msgstr "Laitetta irrotettu"
 
 #: stdio-common/psiginfo.c:139
 msgid "Signal sent by kill()"
-msgstr "Signaalin lähetti kill()"
+msgstr ""
 
 #: stdio-common/psiginfo.c:142
 msgid "Signal sent by sigqueue()"
-msgstr "Signaalin lähetti sigqueue()"
+msgstr ""
 
 #: stdio-common/psiginfo.c:145
 msgid "Signal generated by the expiration of a timer"
@@ -5106,7 +5114,7 @@ msgstr ""
 
 #: stdio-common/psiginfo.c:157
 msgid "Signal sent by tkill()"
-msgstr "Signaalin lähetti tkill()"
+msgstr ""
 
 #: stdio-common/psiginfo.c:162
 msgid "Signal generated by the completion of an asynchronous name lookup request"
@@ -5288,8 +5296,9 @@ msgid "Failed (unspecified error)"
 msgstr "Epäonnistui (määrittelemätön virhe)"
 
 #: sunrpc/clnt_raw.c:115
+#, fuzzy
 msgid "clnt_raw.c: fatal header serialization error"
-msgstr "clnt_raw.c: vakava otsikon sarjallistamisvirhe"
+msgstr "clnt_raw.c: vakava otsikon serialisointivirhe"
 
 #: sunrpc/pm_getmaps.c:77
 msgid "pmap_getmaps.c: rpc problem"
@@ -6816,8 +6825,9 @@ msgid "Interrupted by a signal"
 msgstr "Signaalin keskeyttämä"
 
 #: sysdeps/posix/gai_strerror-strs.h:17
+#, fuzzy
 msgid "Parameter string not correctly encoded"
-msgstr "Parametrimerkkijono ei ole koodattu oikein"
+msgstr "Parametrimerkkijono on väärin koodattu"
 
 #: sysdeps/unix/sysv/linux/i386/readelflib.c:65
 #, c-format
--- glibc/po/sv.po
+++ riscv-glibc/po/sv.po
@@ -1,17 +1,13 @@
 # GNU libc message catalog for Swedish
-# Copyright © 1996, 1998, 2001, 2002, 2003, 2006, 2008, 2009, 2011, 2012, 2013, 2014, 2015, 2016 Free Software Foundation, Inc.
+# Copyright © 1996, 1998, 2001, 2002, 2003, 2006, 2008, 2009, 2011, 2012, 2013, 2014, 2015 Free Software Foundation, Inc.
 # This file is distributed under the same license as the glibc package.
-#
-# Jan Djärv <jan.h.d@swipnet.se>, 1996, 1998, 2001, 2002, 2003, 2006, 2007, 2008, 2009, 2011, 2012, 2013, 2014, 2015.
-# Göran Uddeborg <goeran@uddeborg.se>, 2016.
-#
-# $Revision: 1.3 $
+# Jan Djärv <jan.h.d@swipnet.se>, 1996, 1998, 2001, 2002, 2003, 2006, 2007, 2008, 2009, 2011, 2012, 2013, 2014, 2015
 msgid ""
 msgstr ""
-"Project-Id-Version: libc 2.22-pre1\n"
+"Project-Id-Version: libc 2.21-pre1\n"
 "POT-Creation-Date: 2015-07-31 00:10-0400\n"
-"PO-Revision-Date: 2016-08-02 17:17+0200\n"
-"Last-Translator: Göran Uddeborg <goeran@uddeborg.se>\n"
+"PO-Revision-Date: 2015-01-24 10:35+0100\n"
+"Last-Translator: Jan Djärv <jan.h.d@swipnet.se>\n"
 "Language-Team: Swedish <tp-sv@listor.tp-sv.se>\n"
 "Language: sv\n"
 "MIME-Version: 1.0\n"
@@ -52,7 +48,7 @@ msgstr " [FLAGGA...]"
 #: argp/argp-help.c:1643
 #, c-format
 msgid "Try `%s --help' or `%s --usage' for more information.\n"
-msgstr "Försök med ”%s --help” eller ”%s --usage” för mer information.\n"
+msgstr "Försök med \"%s --help\" eller \"%s --usage\" för mer information\n"
 
 #: argp/argp-help.c:1671
 #, c-format
@@ -308,11 +304,11 @@ msgstr "Användning: xtrace [FLAGGA]...
 #: debug/xtrace.sh:32 elf/sotruss.sh:56 elf/sotruss.sh:67 elf/sotruss.sh:135
 #: malloc/memusage.sh:26
 msgid "Try \\`%s --help' or \\`%s --usage' for more information.\\n"
-msgstr "Försök med ”%s --help” eller ”%s --usage” för mer information\\n"
+msgstr "Försök med \\\"%s --help\\\" eller \\\"%s --usage\\\" för mer information\\n"
 
 #: debug/xtrace.sh:38
 msgid "%s: option '%s' requires an argument.\\n"
-msgstr "%s: flaggan ”%s” kräver ett argument.\\n"
+msgstr "%s: flaggan \\\"%s\\\" kräver ett argument\\n"
 
 #: debug/xtrace.sh:45
 msgid ""
@@ -336,17 +332,19 @@ msgstr ""
 "      --usage             Visa en kort hjälptext\n"
 "   -V,--version           Visa versionsinformation och avsluta\n"
 "\n"
-"Obligatoriska argument för långa flaggor är obligatoriska även för\n"
+"Obligatoriska argument för långa flaggor är obligatoriska  även för\n"
 "motsvarande korta.\n"
 
 #: debug/xtrace.sh:57 elf/ldd.bash.in:55 elf/sotruss.sh:49
 #: malloc/memusage.sh:64
 msgid "For bug reporting instructions, please see:\\\\n%s.\\\\n"
-msgstr "För felrapporteringsinstruktioner, se:\\\\n%s.\\\\nRapportera fel eller synpunkter på översättningen till:\\\\n<tp-sv@listor.tp-sv.se>.\\\\n"
+msgstr ""
+"För felrapporteringsinstruktioner, se:\\\\n%s.\\\\n\n"
+"Rapportera fel eller synpunkter på översättningen till <tp-sv@listor.tp-sv.se>.\\\\n"
 
 #: debug/xtrace.sh:125
 msgid "xtrace: unrecognized option \\`$1'\\n"
-msgstr "xtrace: okänd flagga ”$1”\\n"
+msgstr "xtrace: okänd flagga \"$1\"\\n"
 
 #: debug/xtrace.sh:138
 msgid "No program name given\\n"
@@ -355,12 +353,12 @@ msgstr "Inget programnamn givet\\n"
 #: debug/xtrace.sh:146
 #, sh-format
 msgid "executable \\`$program' not found\\n"
-msgstr "program ”$program” hittades inte\\n"
+msgstr "program \"$program\" hittades inte\\n"
 
 #: debug/xtrace.sh:150
 #, sh-format
 msgid "\\`$program' is no executable\\n"
-msgstr "”$program” är inte en körbar binär\\n"
+msgstr "\"$program\" är inte en körbar binär\\n"
 
 #: dlfcn/dlinfo.c:63
 msgid "RTLD_SELF used in code not dynamically loaded"
@@ -398,7 +396,7 @@ msgstr ", OS ABI: %s %d.%d.%d"
 #: elf/cache.c:157 elf/ldconfig.c:1340
 #, c-format
 msgid "Can't open cache file %s\n"
-msgstr "Kan inte öppna cache-filen %s\n"
+msgstr "Kan inte öppna cache-fil \"%s\"\n"
 
 #: elf/cache.c:171
 #, c-format
@@ -418,7 +416,7 @@ msgstr "%d bibliotek hittades i cache \"
 #: elf/cache.c:426
 #, c-format
 msgid "Can't create temporary cache file %s"
-msgstr "Kan inte skapa en temporär cache-fil %s"
+msgstr "Kan inte skapa temporär cache-fil \"%s\""
 
 #: elf/cache.c:434 elf/cache.c:444 elf/cache.c:448 elf/cache.c:453
 #, c-format
@@ -831,7 +829,7 @@ msgstr "Kan inte ta status (lstat) på %
 #: elf/ldconfig.c:609
 #, c-format
 msgid "Ignored file %s since it is not a regular file."
-msgstr "Ignorerar fil %s eftersom den inte är en vanlig fil."
+msgstr "Ignorerar fil %s eftersom den inte är en vanlig fil"
 
 #: elf/ldconfig.c:618
 #, c-format
@@ -953,7 +951,7 @@ msgstr ""
 
 #: elf/ldd.bash.in:80
 msgid "ldd: option \\`$1' is ambiguous"
-msgstr "ldd: flaggan ”$1” är tvetydig"
+msgstr "ldd: flaggan \"$1\" är tvetydig"
 
 #: elf/ldd.bash.in:87
 msgid "unrecognized option"
@@ -961,7 +959,7 @@ msgstr "okänd flagga"
 
 #: elf/ldd.bash.in:88 elf/ldd.bash.in:125
 msgid "Try \\`ldd --help' for more information."
-msgstr "Försök med \"ldd --help\" för mer information."
+msgstr "Försök med \"ldd --help\" för mer information"
 
 #: elf/ldd.bash.in:124
 msgid "missing file arguments"
@@ -1030,9 +1028,10 @@ msgid "cannot read object name"
 msgstr "kan inte läsa objektnamn"
 
 #: elf/pldd-xx.c:219
-#, c-format
+#, fuzzy, c-format
+#| msgid "cannot allocate memory for program header"
 msgid "cannot allocate buffer for object name"
-msgstr "kan inte allokera en buffert för objektnamn"
+msgstr "kan inte allokera minne för programhuvud"
 
 #: elf/pldd.c:64
 msgid "List dynamic shared objects loaded into process."
@@ -1213,11 +1212,11 @@ msgstr ""
 
 #: elf/sotruss.sh:46
 msgid "Mandatory arguments to long options are also mandatory for any corresponding\\nshort options.\\n"
-msgstr "Obligatoriska respektive valfria argument för långa flaggor är obligatoriska\\nrespektive valfria även för korta.\\n"
+msgstr "Obligatoriska respektive valfria argument för långa flaggor är obligatoriska respektive\\nvalfria även för korta.\\n"
 
 #: elf/sotruss.sh:55
 msgid "%s: option requires an argument -- '%s'\\n"
-msgstr "%s: flaggan kräver ett argument — ”%s”\\n"
+msgstr "%s: flaggan kräver ett argument -- \\\"%s\\\"\\n"
 
 #: elf/sotruss.sh:61
 msgid "%s: option is ambiguous; possibilities:"
@@ -1241,7 +1240,7 @@ msgstr ""
 
 #: elf/sotruss.sh:134
 msgid "%s: unrecognized option '%c%s'\\n"
-msgstr "%s: okänd flagga ”%c%s”\\n"
+msgstr "%s: okänd flagga \\\"%c%s\\\"\\n"
 
 #: elf/sprof.c:77
 msgid "Output selection:"
@@ -1261,7 +1260,7 @@ msgstr "generera anropsgraf"
 
 #: elf/sprof.c:89
 msgid "Read and display shared object profiling data."
-msgstr "Läs och visa profildata för delat objekt."
+msgstr "Läs och visa profildata för delat objekt"
 
 #: elf/sprof.c:94
 msgid "SHOBJ [PROFDATA]"
@@ -1623,7 +1622,7 @@ msgstr "Fel: .netrc kan läsas av andra.
 
 #: inet/ruserpass.c:185
 msgid "Remove password or make file unreadable by others."
-msgstr "Ta bort lösenord eller gör filen oläsbar för andra."
+msgstr "Ta bort lösenord eller gör filen oläsbar för andra"
 
 #: inet/ruserpass.c:277
 #, c-format
@@ -2183,12 +2182,12 @@ msgstr "Inget namn definierat i teckenup
 #: locale/programs/ld-ctype.c:479
 #, c-format
 msgid "character L'\\u%0*x' in class `%s' must be in class `%s'"
-msgstr "tecken L'\\u%0*x' i klassen ”%s” måste vara i klassen ”%s”"
+msgstr "tecken L\"\\u%0*x\" i klass \"%s\" måste vara i klass \"%s\""
 
 #: locale/programs/ld-ctype.c:494
 #, c-format
 msgid "character L'\\u%0*x' in class `%s' must not be in class `%s'"
-msgstr "tecken L'\\u%0*x' i klassen ”%s” får inte vara i klassen ”%s”"
+msgstr "tecken L\"\\u%0*x\" i klass \"%s\" får inte vara i klass \"%s\""
 
 #: locale/programs/ld-ctype.c:508 locale/programs/ld-ctype.c:566
 #, c-format
@@ -2612,7 +2611,7 @@ msgstr "Skriv mer information"
 
 #: locale/programs/locale.c:85
 msgid "Get locale-specific information."
-msgstr "Hämta lokalspecifik information."
+msgstr "Hämta lokalspecifik information"
 
 #: locale/programs/locale.c:88
 msgid ""
@@ -3023,7 +3022,7 @@ msgstr "felaktig mcheck_status, bibliote
 
 #: malloc/memusage.sh:32
 msgid "%s: option '%s' requires an argument\\n"
-msgstr "%s: flaggan ”%s” kräver ett argument\\n"
+msgstr "%s: flaggan \\\"%s\\\" kräver ett argument\\n"
 
 #: malloc/memusage.sh:38
 msgid ""
@@ -3092,11 +3091,11 @@ msgstr ""
 
 #: malloc/memusage.sh:191
 msgid "memusage: option \\`${1##*=}' is ambiguous"
-msgstr "memusage: flaggan ”${1##*=}” är tvetydig"
+msgstr "memusage: flaggan \"${1##*=}\" är tvetydig"
 
 #: malloc/memusage.sh:200
 msgid "memusage: unrecognized option \\`$1'"
-msgstr "memusage: okänd flagga ”$1”"
+msgstr "memusage: okänd flagga \"$1\""
 
 #: malloc/memusage.sh:213
 msgid "No program name given"
@@ -3342,7 +3341,7 @@ msgstr "Kan inte skapa process hos serve
 
 #: nis/nis_error.h:48
 msgid "Master server busy, full dump rescheduled."
-msgstr "Huvudserver är upptagen, full dump åter schemalagd."
+msgstr "Huvudserver är upptagen, full dump åter schemalagd"
 
 #: nis/nis_local_names.c:121
 #, c-format
@@ -3512,7 +3511,7 @@ msgstr "\t\tRättigheter   : "
 
 #: nis/nis_print.c:290
 msgid "Linked Object Type : "
-msgstr "Länkad objekttyp   : "
+msgstr "Länkad objekttyp: "
 
 #: nis/nis_print.c:292
 #, c-format
@@ -3803,14 +3802,15 @@ msgid " (first)"
 msgstr " (första)"
 
 #: nscd/cache.c:288
-#, c-format
+#, fuzzy, c-format
+#| msgid "cannot stat() file `%s': %s"
 msgid "checking for monitored file `%s': %s"
-msgstr "kontrollerar den övervakade filen ”%s”: %s"
+msgstr "kan inte ta status på fil \"%s\": %s"
 
 #: nscd/cache.c:298
 #, c-format
 msgid "monitored file `%s` changed (mtime)"
-msgstr "den övervakade filen ”%s” ändrades (mtime)"
+msgstr ""
 
 #: nscd/cache.c:341
 #, c-format
@@ -3906,32 +3906,34 @@ msgstr "kan inte få uttag (socket) att
 #: nscd/connections.c:973
 #, c-format
 msgid "disabled inotify-based monitoring for file `%s': %s"
-msgstr "avaktiverade inotify-baserad övervakning för filen ”%s”: %s"
+msgstr ""
 
 #: nscd/connections.c:977
 #, c-format
 msgid "monitoring file `%s` (%d)"
-msgstr "övervakar filen ”%s” (%d)"
+msgstr ""
 
 #: nscd/connections.c:990
 #, c-format
 msgid "disabled inotify-based monitoring for directory `%s': %s"
-msgstr "avaktiverade inotify-baserad övervakning av katalogen ”%s”: %s"
+msgstr ""
 
 #: nscd/connections.c:994
-#, c-format
+#, fuzzy, c-format
+#| msgid "Can't open directory %s"
 msgid "monitoring directory `%s` (%d)"
-msgstr "övervakar katalogen ”%s” (%d)"
+msgstr "Kan inte öppna katalog %s"
 
 #: nscd/connections.c:1022
-#, c-format
+#, fuzzy, c-format
+#| msgid "register trace file %s for database %s"
 msgid "monitoring file %s for database %s"
-msgstr "övervakar filen %s för databas %s"
+msgstr "registrera spårningsfil %s för databas %s"
 
 #: nscd/connections.c:1032
 #, c-format
 msgid "stat failed for file `%s'; will try again later: %s"
-msgstr "stat misslyckades för filen ”%s”; kommer försöka igen senare: %s"
+msgstr ""
 
 #: nscd/connections.c:1151
 #, c-format
@@ -4030,42 +4032,44 @@ msgstr "handle_request: begäran mottage
 #: nscd/connections.c:1963
 #, c-format
 msgid "ignored inotify event for `%s` (file exists)"
-msgstr "ignorerade inotify-händelse för ”%s” (filen finns)"
+msgstr ""
 
 #: nscd/connections.c:1968
 #, c-format
 msgid "monitored file `%s` was %s, removing watch"
-msgstr "den övervakade filen ”%s” var %s, tar bort vakten"
+msgstr ""
 
 #: nscd/connections.c:1976 nscd/connections.c:2018
 #, c-format
 msgid "failed to remove file watch `%s`: %s"
-msgstr "misslyckades att ta bort filvakt ”%s”: %s"
+msgstr ""
 
 #: nscd/connections.c:1991
 #, c-format
 msgid "monitored file `%s` was written to"
-msgstr "den övervakade filen ”%s” skrevs till"
+msgstr ""
 
 #: nscd/connections.c:2015
 #, c-format
 msgid "monitored parent directory `%s` was %s, removing watch on `%s`"
-msgstr "den övervakade föräldrakatalogen ”%s” var %s, tar bort vakten av ”%s”"
+msgstr ""
 
 #: nscd/connections.c:2041
 #, c-format
 msgid "monitored file `%s` was %s, adding watch"
-msgstr "den övervakade filen ”%s” var %s, lägger till vakt"
+msgstr ""
 
 #: nscd/connections.c:2053
-#, c-format
+#, fuzzy, c-format
+#| msgid "failed to load shared object `%s'"
 msgid "failed to add file watch `%s`: %s"
-msgstr "misslyckades med att lägga till filvakt ”%s”: %s"
+msgstr "misslyckades med att ladda delat objekt \"%s\""
 
 #: nscd/connections.c:2247 nscd/connections.c:2428
-#, c-format
+#, fuzzy, c-format
+#| msgid "disabled inotify after read error %d"
 msgid "disabled inotify-based monitoring after read error %d"
-msgstr "avaktiverade inotify-baserad övervakning efter läsfel %d"
+msgstr "inaktiverade inotify efter läsfel %d"
 
 #: nscd/connections.c:2543
 msgid "could not initialize conditional variable"
@@ -4195,7 +4199,7 @@ msgstr "Använd separat cache för varje
 
 #: nscd/nscd.c:122
 msgid "Name Service Cache Daemon."
-msgstr "Cache-demon för namntjänsten."
+msgstr "Namntjänst cache-demon"
 
 #: nscd/nscd.c:155 nss/getent.c:1007 nss/makedb.c:206
 #, c-format
@@ -4527,11 +4531,11 @@ msgstr "Access Vector Cache (AVC) starta
 
 #: nscd/selinux.c:368
 msgid "Error querying policy for undefined object classes or permissions."
-msgstr "Fel när policy för odefinierade objektklasser eller rättigheter hämtades."
+msgstr "Fel när policy för odefinierade objektklasser eller rättigheter hämtades"
 
 #: nscd/selinux.c:375
 msgid "Error getting security class for nscd."
-msgstr "Fel när säkerhetsklass för nscd hämtades."
+msgstr "Fel när säkerhetsklass för nscd hämtades"
 
 #: nscd/selinux.c:380
 #, c-format
@@ -4605,7 +4609,7 @@ msgstr "inaktivera DIN-kodning"
 
 #: nss/getent.c:64
 msgid "Get entries from administrative database."
-msgstr "Hämta poster från den administrativa databasen."
+msgstr "Hämta poster från den administrativa databasen"
 
 #: nss/getent.c:148 nss/getent.c:477 nss/getent.c:522
 #, c-format
@@ -4648,7 +4652,7 @@ msgstr "Genererad rad som inte ingår i
 
 #: nss/makedb.c:131
 msgid "Create simple database from textual input."
-msgstr "Skapa en enkel databas från textuell indata."
+msgstr "Skapa en enkel databas från textuell indata"
 
 #: nss/makedb.c:134
 msgid ""
@@ -5408,7 +5412,7 @@ msgstr "Kan inte ange netid-flaggan utan
 #: sunrpc/rpc_main.c:1374
 #, c-format
 msgid "Cannot use table flags with newstyle!\n"
-msgstr "Kan inte ange tabellflaggor med ny stil!\n"
+msgstr "Kan inte ange tabellflaggor med ny stil\n"
 
 #: sunrpc/rpc_main.c:1393
 #, c-format
@@ -7266,9 +7270,18 @@ msgstr "tidszonsförkortning skiljer sig
 
 #: timezone/zic.c:2789
 msgid "too many, or too long, time zone abbreviations"
-msgstr "för många eller för långa tidszonsförkortningar"
+msgstr "för många eller för långa tidszonförkortningar"
 
 #: timezone/zic.c:2829
 #, c-format
 msgid "%s: Can't create directory %s: %s\n"
 msgstr "%s: Kan inte skapa katalog %s: %s\n"
+
+#~ msgid "cannot load any more object with static TLS"
+#~ msgstr "kan inte ladda fler objekt med statiskt TLS"
+
+#~ msgid "%s: no PLTREL found in object %s\n"
+#~ msgstr "%s: hittade inga PLTREL i objekt %s\n"
+
+#~ msgid "cannot create internal descriptors"
+#~ msgstr "kan inte skapa interna deskriptorer"
--- glibc/sunrpc/rpc_main.c
+++ riscv-glibc/sunrpc/rpc_main.c
@@ -38,7 +38,9 @@
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
+#if !defined(__FreeBSD__) && !defined(__APPLE__)
 #include <libintl.h>
+#endif
 #include <locale.h>
 #include <ctype.h>
 #include <sys/types.h>
@@ -54,6 +56,10 @@
 #include "../version.h"
 #define PACKAGE _libc_intl_domainname
 
+#ifdef __FreeBSD__
+#define stat64 stat
+#endif
+
 #define EXTEND	1		/* alias for TRUE */
 #define DONT_EXTEND	0	/* alias for FALSE */
 
--- glibc/sunrpc/rpc_scan.c
+++ riscv-glibc/sunrpc/rpc_scan.c
@@ -37,7 +37,9 @@
 #include <stdio.h>
 #include <ctype.h>
 #include <string.h>
+#ifndef __FreeBSD__
 #include <libintl.h>
+#endif
 #include "rpc_scan.h"
 #include "rpc_parse.h"
 #include "rpc_util.h"
--- glibc/sysdeps/riscv/atomic-machine.h
+++ riscv-glibc/sysdeps/riscv/atomic-machine.h
@@ -0,0 +1,128 @@
+/* Low-level functions for atomic operations. RISC-V version.
+   Copyright (C) 2011-2016 Free Software Foundation, Inc.
+
+   Contributed by Andrew Waterman (waterman@cs.berkeley.edu) at UC Berkeley.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RISCV_BITS_ATOMIC_H
+#define _RISCV_BITS_ATOMIC_H 1
+
+#include <inttypes.h>
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef int64_t atomic64_t;
+typedef uint64_t uatomic64_t;
+typedef int_fast64_t atomic_fast64_t;
+typedef uint_fast64_t uatomic_fast64_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+#ifdef __riscv_atomic
+
+#ifdef __riscv64
+# define __HAVE_64B_ATOMICS 1
+#else
+# define __HAVE_64B_ATOMICS 0
+#endif
+
+#define USE_ATOMIC_COMPILER_BUILTINS 1
+
+#define asm_amo(which, ordering, mem, value) ({ 		\
+  typeof(*mem) __tmp; 						\
+  if (sizeof(__tmp) == 4)					\
+    asm volatile (which ".w" ordering "\t%0, %z2, %1"		\
+		  : "=r"(__tmp), "+A"(*(mem))			\
+		  : "rJ"(value));				\
+  else if (sizeof(__tmp) == 8)					\
+    asm volatile (which ".d" ordering "\t%0, %z2, %1"		\
+		  : "=r"(__tmp), "+A"(*(mem))			\
+		  : "rJ"(value));				\
+  else								\
+    abort();							\
+  __tmp; })
+
+/* Atomic compare and exchange. */
+
+#define atomic_cas(ordering, mem, newval, oldval) ({ 		\
+  typeof(*mem) __tmp; 						\
+  int __tmp2; 							\
+  if (sizeof(__tmp) == 4)					\
+    asm volatile ("1: lr.w" ordering "\t%0, %2\n"		\
+		  "bne\t%0, %z4, 1f\n"				\
+		  "sc.w" ordering "\t%1, %z3, %2\n"		\
+		  "bnez\t%1, 1b\n"				\
+		  "1:"						\
+		  : "=&r"(__tmp), "=&r"(__tmp2), "+A"(*(mem))	\
+		  : "rJ"(newval), "rJ"(oldval));		\
+  else if (sizeof(__tmp) == 8)					\
+    asm volatile ("1: lr.d" ordering "\t%0, %2\n"		\
+		  "bne\t%0, %z4, 1f\n"				\
+		  "sc.d" ordering "\t%1, %z3, %2\n"		\
+		  "bnez\t%1, 1b\n"				\
+		  "1:"						\
+		  : "=&r"(__tmp), "=&r"(__tmp2), "+A"(*(mem))	\
+		  : "rJ"(newval), "rJ"(oldval));		\
+  else								\
+    abort();							\
+  __tmp; })
+
+#define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
+  atomic_cas(".aq", mem, newval, oldval)
+
+#define atomic_compare_and_exchange_val_rel(mem, newval, oldval) \
+  atomic_cas(".rl", mem, newval, oldval)
+
+/* Atomic exchange (without compare).  */
+
+#define atomic_exchange_acq(mem, value) asm_amo("amoswap", ".aq", mem, value)
+#define atomic_exchange_rel(mem, value) asm_amo("amoswap", ".rl", mem, value)
+
+
+/* Atomically add value and return the previous (unincremented) value.  */
+
+#define atomic_exchange_and_add(mem, value) asm_amo("amoadd", "", mem, value)
+
+#define atomic_max(mem, value) asm_amo("amomaxu", "", mem, value)
+#define atomic_min(mem, value) asm_amo("amominu", "", mem, value)
+
+#define atomic_bit_test_set(mem, bit)                   \
+  ({ typeof(*mem) __mask = (typeof(*mem))1 << (bit);    \
+     asm_amo("amoor", "", mem, __mask) & __mask; })
+
+#define atomic_full_barrier() __sync_synchronize()
+
+#define catomic_exchange_and_add(mem, value)		\
+  atomic_exchange_and_add(mem, value)
+#define catomic_max(mem, value) atomic_max(mem, value)
+
+#else /* __riscv_atomic */
+
+#define __HAVE_64B_ATOMICS 0
+#define USE_ATOMIC_COMPILER_BUILTINS 0
+
+#endif /* !__riscv_atomic */
+
+#endif /* bits/atomic.h */
--- glibc/sysdeps/riscv/bits/endian.h
+++ riscv-glibc/sysdeps/riscv/bits/endian.h
@@ -0,0 +1,5 @@
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __LITTLE_ENDIAN
--- glibc/sysdeps/riscv/bits/fenv.h
+++ riscv-glibc/sysdeps/riscv/bits/fenv.h
@@ -0,0 +1,57 @@
+/* Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+enum
+  {
+    FE_INEXACT = 0x01,
+#define FE_INEXACT	FE_INEXACT
+    FE_UNDERFLOW = 0x02,
+#define FE_UNDERFLOW	FE_UNDERFLOW
+    FE_OVERFLOW = 0x04,
+#define FE_OVERFLOW	FE_OVERFLOW
+    FE_DIVBYZERO = 0x08,
+#define FE_DIVBYZERO	FE_DIVBYZERO
+    FE_INVALID = 0x10,
+#define FE_INVALID	FE_INVALID
+  };
+
+#define FE_ALL_EXCEPT \
+	(FE_INEXACT | FE_DIVBYZERO | FE_UNDERFLOW | FE_OVERFLOW | FE_INVALID)
+
+enum
+  {
+    FE_TONEAREST = 0x0,
+#define FE_TONEAREST	FE_TONEAREST
+    FE_TOWARDZERO = 0x1,
+#define FE_TOWARDZERO	FE_TOWARDZERO
+    FE_DOWNWARD = 0x2,
+#define FE_DOWNWARD	FE_DOWNWARD
+    FE_UPWARD = 0x3
+#define FE_UPWARD	FE_UPWARD
+  };
+
+
+typedef unsigned int fexcept_t;
+typedef unsigned int fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((__const fenv_t *) -1)
--- glibc/sysdeps/riscv/bits/link.h
+++ riscv-glibc/sysdeps/riscv/bits/link.h
@@ -0,0 +1,56 @@
+/* Copyright (C) 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+typedef struct La_riscv_regs
+{
+  unsigned long lr_reg[8]; /* a0 - a7 */
+  double lr_fpreg[8]; /* fa0 - fa7 */
+  unsigned long lr_ra;
+  unsigned long lr_sp;
+} La_riscv_regs;
+
+/* Return values for calls from PLT on RISC-V.  */
+typedef struct La_riscv_retval
+{
+  unsigned long lrv_a0;
+  unsigned long lrv_a1;
+  double lrv_fa0;
+  double lrv_fa1;
+} La_riscv_retval;
+
+__BEGIN_DECLS
+
+extern ElfW(Addr) la_riscv_gnu_pltenter (ElfW(Sym) *__sym, unsigned int __ndx,
+					 uintptr_t *__refcook,
+					 uintptr_t *__defcook,
+					 La_riscv_regs *__regs,
+					 unsigned int *__flags,
+					 const char *__symname,
+					 long int *__framesizep);
+extern unsigned int la_riscv_gnu_pltexit (ElfW(Sym) *__sym, unsigned int __ndx,
+					  uintptr_t *__refcook,
+					  uintptr_t *__defcook,
+					  const La_riscv_regs *__inregs,
+					  La_riscv_retval *__outregs,
+					  const char *__symname);
+
+__END_DECLS
--- glibc/sysdeps/riscv/bits/mathdef.h
+++ riscv-glibc/sysdeps/riscv/bits/mathdef.h
@@ -0,0 +1,43 @@
+/* Copyright (C) 1997, 1998, 1999, 2000, 2002, 2003, 2004, 2007
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _MATH_H && !defined _COMPLEX_H
+# error "Never use <bits/mathdef.h> directly; include <math.h> instead"
+#endif
+
+#if defined  __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
+# define _MATH_H_MATHDEF	1
+
+/* MIPS has `float' and `double' operations.  */
+typedef float float_t;		/* `float' expressions are evaluated as
+				   `float'.  */
+typedef double double_t;	/* `double' expressions are evaluated as
+				   `double'.  */
+
+/* The values returned by `ilogb' for 0 and NaN respectively.  */
+# define FP_ILOGB0	(-2147483647)
+# define FP_ILOGBNAN	2147483647
+
+#endif	/* ISO C99 */
+
+#if ! defined __NO_LONG_DOUBLE_MATH
+/* Signal that we do not really have a `long double'.  This disables the
+   declaration of all the `long double' function variants.  */
+# define __NO_LONG_DOUBLE_MATH	1
+#endif
--- glibc/sysdeps/riscv/bits/mathinline.h
+++ riscv-glibc/sysdeps/riscv/bits/mathinline.h
@@ -0,0 +1,44 @@
+/* Copyright (C) 2011-2015 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _MATH_H
+# error "Never use <bits/mathinline.h> directly; include <math.h> instead."
+#endif
+
+#ifndef __extern_always_inline
+# define __MATH_INLINE __inline
+#else
+# define __MATH_INLINE __extern_always_inline
+#endif
+
+
+#if defined __USE_ISOC99 && defined __GNUC__
+
+/* Test for negative number.  Used in the signbit() macro.  */
+__MATH_INLINE int
+__NTH (__signbitf (float __x))
+{
+  return __builtin_signbitf (__x);
+}
+__MATH_INLINE int
+__NTH (__signbit (double __x))
+{
+  return __builtin_signbit (__x);
+}
+
+#endif
--- glibc/sysdeps/riscv/bits/setjmp.h
+++ riscv-glibc/sysdeps/riscv/bits/setjmp.h
@@ -0,0 +1,43 @@
+/* Define the machine-dependent type `jmp_buf'.  RISC-V version.
+   Copyright (C) 1992,1993,1995,1997,2000,2002,2003,2004,2005,2006
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RISCV_BITS_SETJMP_H
+#define _RISCV_BITS_SETJMP_H
+
+typedef struct __jmp_buf_internal_tag
+  {
+    /* Program counter.  */
+    long __pc;
+    /* Callee-saved registers. */
+    long __regs[12];
+    /* Stack pointer.  */
+    long __sp;
+    /* Thread pointer. */
+    long __tp;
+    /* Floating point status register.  */
+    long __fsr;
+
+    /* Callee-saved floating point registers.
+       Note that there are an even number of preceding words in this struct,
+       so no padding will be inserted before __fpregs, even for RV32. */
+    double __fpregs[12];
+  } __jmp_buf[1];
+
+#endif /* _RISCV_BITS_SETJMP_H */
--- glibc/sysdeps/riscv/bits/string.h
+++ riscv-glibc/sysdeps/riscv/bits/string.h
@@ -0,0 +1,25 @@
+/* This file should provide inline versions of string functions.
+
+   Surround GCC-specific parts with #ifdef __GNUC__, and use `__extern_inline'.
+
+   This file should define __STRING_INLINES if functions are actually defined
+   as inlines.  */
+
+#ifndef _BITS_STRING_H
+#define _BITS_STRING_H	1
+
+#define _STRING_INLINE_unaligned   0
+
+#if defined(__GNUC__) && !defined(__cplusplus)
+
+static __inline__ unsigned long __libc_detect_null(unsigned long w)
+{
+  unsigned long mask = 0x7f7f7f7f;
+  if (sizeof(long) == 8)
+    mask = ((mask << 16) << 16) | mask;
+  return ~(((w & mask) + mask) | w | mask);
+}
+
+#endif /* __GNUC__ && !__cplusplus */
+
+#endif /* bits/string.h */
--- glibc/sysdeps/riscv/bits/wordsize.h
+++ riscv-glibc/sysdeps/riscv/bits/wordsize.h
@@ -0,0 +1,24 @@
+/* Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if defined __riscv64
+#define __WORDSIZE 64
+#define __WORDSIZE_TIME64_COMPAT32 1
+#else
+#define __WORDSIZE 32
+#endif
--- glibc/sysdeps/riscv/bsd-_setjmp.c
+++ riscv-glibc/sysdeps/riscv/bsd-_setjmp.c
@@ -0,0 +1 @@
+/* _setjmp is implemented in setjmp.S */
--- glibc/sysdeps/riscv/bsd-setjmp.c
+++ riscv-glibc/sysdeps/riscv/bsd-setjmp.c
@@ -0,0 +1 @@
+/* setjmp is implemented in setjmp.S */
--- glibc/sysdeps/riscv/configure
+++ riscv-glibc/sysdeps/riscv/configure
@@ -0,0 +1,87 @@
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/riscv/elf.
+
+$as_echo "#define PI_STATIC_AND_HIDDEN 1" >>confdefs.h
+
--- glibc/sysdeps/riscv/configure.in
+++ riscv-glibc/sysdeps/riscv/configure.in
@@ -0,0 +1,4 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/riscv/elf.
+
+AC_DEFINE(PI_STATIC_AND_HIDDEN)
--- glibc/sysdeps/riscv/crti.S
+++ riscv-glibc/sysdeps/riscv/crti.S
@@ -0,0 +1,16 @@
+/* Facilitate pthread initialization using init_array.  */
+
+#ifdef PREINIT_FUNCTION
+
+#if PREINIT_FUNCTION_WEAK
+# error PREINIT_FUNCTION_WEAK is unsupported
+#endif
+
+	.section .init_array, "aw"
+#ifdef __riscv64
+	.dword PREINIT_FUNCTION
+#else
+	.word PREINIT_FUNCTION
+#endif
+
+#endif
--- glibc/sysdeps/riscv/dl-machine.h
+++ riscv-glibc/sysdeps/riscv/dl-machine.h
@@ -0,0 +1,331 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  MIPS version.
+   Copyright (C) 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*  FIXME: Profiling of shared libraries is not implemented yet.  */
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "RISC-V"
+#define EM_RISCV 243
+
+/* Relocs. */
+#define R_RISCV_NONE          0
+#define R_RISCV_32            1
+#define R_RISCV_64            2
+#define R_RISCV_RELATIVE      3
+#define R_RISCV_COPY          4
+#define R_RISCV_JUMP_SLOT     5
+#define R_RISCV_TLS_DTPMOD32  6
+#define R_RISCV_TLS_DTPMOD64  7
+#define R_RISCV_TLS_DTPREL32  8
+#define R_RISCV_TLS_DTPREL64  9
+#define R_RISCV_TLS_TPREL32  10
+#define R_RISCV_TLS_TPREL64  11
+
+#include <entry.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for MIPS.
+#endif
+
+#include <sys/asm.h>
+#include <dl-tls.h>
+
+#ifndef _RTLD_PROLOGUE
+# define _RTLD_PROLOGUE(entry)						\
+	".globl\t" __STRING(entry) "\n\t"				\
+	".type\t" __STRING(entry) ", @function\n"			\
+	__STRING(entry) ":\n\t"
+#endif
+
+#ifndef _RTLD_EPILOGUE
+# define _RTLD_EPILOGUE(entry)						\
+	".size\t" __STRING(entry) ", . - " __STRING(entry) "\n\t"
+#endif
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.
+   This only makes sense on MIPS when using PLTs, so choose the
+   PLT relocation (not encountered when not using PLTs).  */
+#define ELF_MACHINE_JMP_SLOT			R_RISCV_JUMP_SLOT
+#define elf_machine_type_class(type)				\
+  ((ELF_RTYPE_CLASS_PLT * ((type) == ELF_MACHINE_JMP_SLOT	\
+     || (_RISCV_SZPTR == 32 && (type) == R_RISCV_TLS_DTPREL32)	\
+     || (_RISCV_SZPTR == 32 && (type) == R_RISCV_TLS_DTPMOD32)	\
+     || (_RISCV_SZPTR == 32 && (type) == R_RISCV_TLS_TPREL32)	\
+     || (_RISCV_SZPTR == 64 && (type) == R_RISCV_TLS_DTPREL64)	\
+     || (_RISCV_SZPTR == 64 && (type) == R_RISCV_TLS_DTPMOD64)	\
+     || (_RISCV_SZPTR == 64 && (type) == R_RISCV_TLS_TPREL64)))	\
+   | (ELF_RTYPE_CLASS_COPY * ((type) == R_RISCV_COPY)))
+
+#define ELF_MACHINE_NO_REL 1
+#define ELF_MACHINE_NO_RELA 0
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute_used__
+elf_machine_matches_host (const ElfW(Ehdr) *ehdr)
+{
+  return ehdr->e_machine == EM_RISCV;
+}
+
+/* Return the link-time address of _DYNAMIC.  */
+static inline ElfW(Addr)
+elf_machine_dynamic (void)
+{
+  extern ElfW(Addr) _GLOBAL_OFFSET_TABLE_ __attribute__((visibility("hidden")));
+  return _GLOBAL_OFFSET_TABLE_;
+}
+
+#define STRINGXP(X) __STRING(X)
+#define STRINGXV(X) STRINGV_(X)
+#define STRINGV_(...) # __VA_ARGS__
+
+/* Return the run-time load address of the shared object.  */
+static inline ElfW(Addr)
+elf_machine_load_address (void)
+{
+  ElfW(Addr) load_addr;
+  asm ("lla %0, _DYNAMIC" : "=r"(load_addr));
+  return load_addr - elf_machine_dynamic ();
+}
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point. */
+
+#define RTLD_START asm (\
+	".text\n\
+	" _RTLD_PROLOGUE(ENTRY_POINT) "\
+	move a0, sp\n\
+	jal _dl_start\n\
+	# Stash user entry point in s0.\n\
+	move s0, a0\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	lw a0, _dl_skip_args\n\
+	# Load the original argument count.\n\
+	" STRINGXP(REG_L) " a1, 0(sp)\n\
+	# Subtract _dl_skip_args from it.\n\
+	sub a1, a1, a0\n\
+	# Adjust the stack pointer to skip _dl_skip_args words.\n\
+	sll a0, a0, " STRINGXP (PTRLOG) "\n\
+	add sp, sp, a0\n\
+	# Save back the modified argument count.\n\
+	" STRINGXP(REG_S) " a1, 0(sp)\n\
+	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env) \n\
+	" STRINGXP(REG_L) " a0, _rtld_local\n\
+	add a2, sp, " STRINGXP (SZREG) "\n\
+	sll a3, a1, " STRINGXP (PTRLOG) "\n\
+	add a3, a3, a2\n\
+	add a3, a3, " STRINGXP (SZREG) "\n\
+	# Call the function to run the initializers.\n\
+	jal _dl_init\n\
+	# Pass our finalizer function to _start.\n\
+	lla a0, _dl_fini\n\
+	# Jump to the user entry point.\n\
+	jr s0\n\
+	" _RTLD_EPILOGUE(ENTRY_POINT) "\
+	.previous" \
+);
+
+/* Names of the architecture-specific auditing callback functions.  */
+# ifdef __riscv64
+#  define ARCH_LA_PLTENTER mips_n64_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n64_gnu_pltexit
+# else
+#  define ARCH_LA_PLTENTER mips_n32_gnu_pltenter
+#  define ARCH_LA_PLTEXIT mips_n32_gnu_pltexit
+# endif
+
+/* Bias .got.plt entry by the offset requested by the PLT header. */
+#define elf_machine_plt_value(map, reloc, value) (value)
+#define elf_machine_fixup_plt(map, t, reloc, reloc_addr, value) \
+  (*(ElfW(Addr) *)(reloc_addr) = (value))
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+/* Perform a relocation described by R_INFO at the location pointed to
+   by RELOC_ADDR.  SYM is the relocation symbol specified by R_INFO and
+   MAP is the object containing the reloc.  */
+
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_rela (struct link_map *map, const ElfW(Rela) *reloc,
+		  const ElfW(Sym) *sym, const struct r_found_version *version,
+		  void *const reloc_addr, int skip_ifunc)
+{
+  ElfW(Addr) r_info = reloc->r_info;
+  const unsigned long int r_type = ELFW(R_TYPE) (r_info);
+  ElfW(Addr) *addr_field = (ElfW(Addr) *) reloc_addr;
+  const ElfW(Sym) *const __attribute__((unused)) refsym = sym;
+  struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
+  ElfW(Addr) value = 0;
+  if (sym_map != NULL)
+    value = sym_map->l_addr + sym->st_value + reloc->r_addend;
+
+  switch (r_type)
+    {
+#ifndef RTLD_BOOTSTRAP
+    case __WORDSIZE == 64 ? R_RISCV_TLS_DTPMOD64 : R_RISCV_TLS_DTPMOD32:
+      if (sym_map)
+	*addr_field = sym_map->l_tls_modid;
+      break;
+
+    case __WORDSIZE == 64 ? R_RISCV_TLS_DTPREL64 : R_RISCV_TLS_DTPREL32:
+      if (sym != NULL)
+	*addr_field = TLS_DTPREL_VALUE (sym) + reloc->r_addend;
+      break;
+
+    case __WORDSIZE == 64 ? R_RISCV_TLS_TPREL64 : R_RISCV_TLS_TPREL32:
+      if (sym != NULL)
+	{
+	  CHECK_STATIC_TLS (map, sym_map);
+	  *addr_field = TLS_TPREL_VALUE (sym_map, sym) + reloc->r_addend;
+	}
+      break;
+
+    case R_RISCV_COPY:
+      {
+	if (__builtin_expect (sym == NULL, 0))
+	  /* This can happen in trace mode if an object could not be
+	     found.  */
+	  break;
+
+	/* Handle TLS copy relocations.  */
+	if (__glibc_unlikely (ELFW(ST_TYPE) (sym->st_info) == STT_TLS))
+	  {
+	    /* There's nothing to do if the symbol is in .tbss.  */
+	    if (__glibc_likely (sym->st_value >= sym_map->l_tls_initimage_size))
+	      break;
+	    value += (ElfW(Addr)) sym_map->l_tls_initimage - sym_map->l_addr;
+	  }
+
+	size_t size = sym->st_size;
+	if (__builtin_expect (sym->st_size != refsym->st_size, 0))
+	  {
+	    const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	    if (sym->st_size > refsym->st_size)
+	      size = refsym->st_size;
+	    if (sym->st_size > refsym->st_size || GLRO(dl_verbose))
+	      _dl_error_printf ("\
+  %s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				rtld_progname ?: "<program name unknown>",
+				strtab + refsym->st_name);
+	  }
+
+	memcpy (reloc_addr, (void *)value, size);
+	break;
+      }
+#endif
+
+#if !defined RTLD_BOOTSTRAP || !defined HAVE_Z_COMBRELOC
+    case R_RISCV_RELATIVE:
+      {
+# if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC
+	/* This is defined in rtld.c, but nowhere in the static libc.a;
+	   make the reference weak so static programs can still link.
+	   This declaration cannot be done when compiling rtld.c
+	   (i.e. #ifdef RTLD_BOOTSTRAP) because rtld.c contains the
+	   common defn for _dl_rtld_map, which is incompatible with a
+	   weak decl in the same file.  */
+#  ifndef SHARED
+	weak_extern (GL(dl_rtld_map));
+#  endif
+	if (map != &GL(dl_rtld_map)) /* Already done in rtld itself.  */
+# endif
+	  *addr_field = map->l_addr + reloc->r_addend;
+      break;
+    }
+#endif
+
+    case R_RISCV_JUMP_SLOT:
+    case __WORDSIZE == 64 ? R_RISCV_64 : R_RISCV_32:
+      *addr_field = value;
+      break;
+
+    case R_RISCV_NONE:
+      break;
+
+    default:
+      _dl_reloc_bad_type (map, r_type, 0);
+      break;
+    }
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_rela_relative (ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
+			  void *const reloc_addr)
+{
+  *(ElfW(Addr) *)reloc_addr = l_addr + reloc->r_addend;
+}
+
+auto inline void
+__attribute__((always_inline))
+elf_machine_lazy_rel (struct link_map *map, ElfW(Addr) l_addr,
+		      const ElfW(Rela) *reloc, int skip_ifunc)
+{
+  ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned int r_type = ELFW(R_TYPE) (reloc->r_info);
+
+  /* Check for unexpected PLT reloc type.  */
+  if (__builtin_expect (r_type == R_RISCV_JUMP_SLOT, 1))
+    {
+      if (__builtin_expect (map->l_mach.plt, 0) == 0)
+	{
+	  if (l_addr)
+	    *reloc_addr += l_addr;
+	}
+      else
+	*reloc_addr = map->l_mach.plt;
+    }
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+/* Set up the loaded object described by L so its stub function
+   will jump to the on-demand fixup code __dl_runtime_resolve.  */
+
+auto inline int
+__attribute__((always_inline))
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+#ifndef RTLD_BOOTSTRAP
+  /* If using PLTs, fill in the first two entries of .got.plt.  */
+  if (l->l_info[DT_JMPREL])
+    {
+      extern void _dl_runtime_resolve (void) __attribute__((visibility("hidden")));
+      ElfW(Addr) *gotplt = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
+      /* If a library is prelinked but we have to relocate anyway,
+	 we have to be able to undo the prelinking of .got.plt.
+	 The prelinker saved the address of .plt for us here.  */
+      if (gotplt[1])
+	l->l_mach.plt = gotplt[1] + l->l_addr;
+      gotplt[0] = (ElfW(Addr)) &_dl_runtime_resolve;
+      gotplt[1] = (ElfW(Addr)) l;
+    }
+#endif
+
+  return lazy;
+}
+
+#endif /* RESOLVE_MAP */
--- glibc/sysdeps/riscv/dl-tls.h
+++ riscv-glibc/sysdeps/riscv/dl-tls.h
@@ -0,0 +1,49 @@
+/* Thread-local storage handling in the ELF dynamic linker.  MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+/* The thread pointer points to the first static TLS block.  */
+#define TLS_TP_OFFSET		0
+
+/* Dynamic thread vector pointers point 0x800 past the start of each
+   TLS block.  */
+#define TLS_DTV_OFFSET		0x800
+
+/* Compute the value for a GOTTPREL reloc.  */
+#define TLS_TPREL_VALUE(sym_map, sym) \
+  ((sym_map)->l_tls_offset + (sym)->st_value - TLS_TP_OFFSET)
+
+/* Compute the value for a DTPREL reloc.  */
+#define TLS_DTPREL_VALUE(sym) \
+  ((sym)->st_value - TLS_DTV_OFFSET)
+
+extern void *__tls_get_addr (tls_index *ti);
+
+# define GET_ADDR_OFFSET	(ti->ti_offset + TLS_DTV_OFFSET)
+# define __TLS_GET_ADDR(__ti)	(__tls_get_addr (__ti) - TLS_DTV_OFFSET)
+
+/* Value used for dtv entries for which the allocation is delayed.  */
+#define TLS_DTV_UNALLOCATED	((void *) -1l)
--- glibc/sysdeps/riscv/dl-trampoline.S
+++ riscv-glibc/sysdeps/riscv/dl-trampoline.S
@@ -0,0 +1,41 @@
+#include <sysdep.h>
+#include <sys/asm.h>
+
+/* Assembler veneer called from the PLT header code for lazy loading.
+   The PLT header passes its own args in t0-t2. */
+
+ENTRY(_dl_runtime_resolve)
+  # Save arguments to stack.
+  addi sp, sp, -10*SZREG
+  REG_S ra, 9*SZREG(sp)
+  REG_S a0, 1*SZREG(sp)
+  REG_S a1, 2*SZREG(sp)
+  REG_S a2, 3*SZREG(sp)
+  REG_S a3, 4*SZREG(sp)
+  REG_S a4, 5*SZREG(sp)
+  REG_S a5, 6*SZREG(sp)
+  REG_S a6, 7*SZREG(sp)
+  REG_S a7, 8*SZREG(sp)
+
+  # Update .got.plt and obtain runtime address of callee.
+  slli a1, t1, 1
+  mv a0, t0       # link map
+  add a1, a1, t1  # reloc offset (== thrice the .got.plt offset)
+  jal _dl_fixup
+  move t0, a0
+
+  # Restore arguments from stack.
+  REG_L ra, 9*SZREG(sp)
+  REG_L a0, 1*SZREG(sp)
+  REG_L a1, 2*SZREG(sp)
+  REG_L a2, 3*SZREG(sp)
+  REG_L a3, 4*SZREG(sp)
+  REG_L a4, 5*SZREG(sp)
+  REG_L a5, 6*SZREG(sp)
+  REG_L a6, 7*SZREG(sp)
+  REG_L a7, 8*SZREG(sp)
+  addi sp, sp, 10*SZREG
+
+  # Invoke the callee.
+  jr t0
+END(_dl_runtime_resolve)
--- glibc/sysdeps/riscv/fpu/fclrexcpt.c
+++ riscv-glibc/sysdeps/riscv/fpu/fclrexcpt.c
@@ -0,0 +1,30 @@
+/* Clear given exceptions in current floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feclearexcept (int excepts)
+{
+  asm volatile ("csrc fflags, %0" : : "r"(excepts));
+  return 0;
+}
+libm_hidden_def (feclearexcept)
--- glibc/sysdeps/riscv/fpu/fedisblxcpt.c
+++ riscv-glibc/sysdeps/riscv/fpu/fedisblxcpt.c
@@ -0,0 +1,29 @@
+/* Disable floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fedisableexcept (int excepts)
+{
+  /* FP exceptions never generate traps. */
+  return 0;
+}
--- glibc/sysdeps/riscv/fpu/feenablxcpt.c
+++ riscv-glibc/sysdeps/riscv/fpu/feenablxcpt.c
@@ -0,0 +1,29 @@
+/* Enable floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+feenableexcept (int excepts)
+{
+  /* FP exceptions never generate traps. */
+  return -1;
+}
--- glibc/sysdeps/riscv/fpu/fegetenv.c
+++ riscv-glibc/sysdeps/riscv/fpu/fegetenv.c
@@ -0,0 +1,34 @@
+/* Store current floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+__fegetenv (fenv_t *envp)
+{
+  _FPU_GETCW (*envp);
+
+  /* Success.  */
+  return 0;
+}
+libm_hidden_def (__fegetenv)
+weak_alias (__fegetenv, fegetenv)
+libm_hidden_weak (fegetenv)
--- glibc/sysdeps/riscv/fpu/fegetexcept.c
+++ riscv-glibc/sysdeps/riscv/fpu/fegetexcept.c
@@ -0,0 +1,29 @@
+/* Get enabled floating-point exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetexcept (void)
+{
+  /* FP exceptions never generate traps. */
+  return 0;
+}
--- glibc/sysdeps/riscv/fpu/fegetround.c
+++ riscv-glibc/sysdeps/riscv/fpu/fegetround.c
@@ -0,0 +1,33 @@
+/* Return current rounding direction.
+   Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+__fegetround (void)
+{
+  int round;
+  _FPU_GETROUND (round);
+  return round;
+}
+libm_hidden_def (__fegetround)
+weak_alias (__fegetround, fegetround)
+libm_hidden_weak (fegetround)
--- glibc/sysdeps/riscv/fpu/feholdexcpt.c
+++ riscv-glibc/sysdeps/riscv/fpu/feholdexcpt.c
@@ -0,0 +1,32 @@
+/* Store current floating-point environment and clear exceptions.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <math_private.h>
+
+int
+__feholdexcept (fenv_t *envp)
+{
+  libc_feholdexcept_riscv (envp);
+  return 0;
+}
+libm_hidden_def (__feholdexcept)
+weak_alias (__feholdexcept, feholdexcept)
+libm_hidden_weak (feholdexcept)
--- glibc/sysdeps/riscv/fpu/fesetenv.c
+++ riscv-glibc/sysdeps/riscv/fpu/fesetenv.c
@@ -0,0 +1,32 @@
+/* Install given floating-point environment.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <math_private.h>
+
+int
+__fesetenv (const fenv_t *envp)
+{
+  libc_fesetenv_riscv (envp);
+  return 0;
+}
+libm_hidden_def (__fesetenv)
+weak_alias (__fesetenv, fesetenv)
+libm_hidden_weak (fesetenv)
--- glibc/sysdeps/riscv/fpu/fesetround.c
+++ riscv-glibc/sysdeps/riscv/fpu/fesetround.c
@@ -0,0 +1,41 @@
+/* Set current rounding direction.
+   Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+__fesetround (int round)
+{
+  switch (round)
+    {
+    case FE_TONEAREST:
+    case FE_TOWARDZERO:
+    case FE_DOWNWARD:
+    case FE_UPWARD:
+      _FPU_SETROUND (round);
+      return 0;
+    default:
+      return round; /* a nonzero value */
+    }
+}
+libm_hidden_def (__fesetround)
+weak_alias (__fesetround, fesetround)
+libm_hidden_weak (fesetround)
--- glibc/sysdeps/riscv/fpu/feupdateenv.c
+++ riscv-glibc/sysdeps/riscv/fpu/feupdateenv.c
@@ -0,0 +1,32 @@
+/* Install given floating-point environment and raise exceptions.
+   Copyright (C) 1998, 1999, 2000, 2002, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <math_private.h>
+
+int
+__feupdateenv (const fenv_t *envp)
+{
+  libc_feupdateenv_riscv (envp);
+  return 0;
+}
+libm_hidden_def (__feupdateenv)
+weak_alias (__feupdateenv, feupdateenv)
+libm_hidden_weak (feupdateenv)
--- glibc/sysdeps/riscv/fpu/fgetexcptflg.c
+++ riscv-glibc/sysdeps/riscv/fpu/fgetexcptflg.c
@@ -0,0 +1,33 @@
+/* Store current representation for exceptions.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fegetexceptflag (fexcept_t *flagp, int excepts)
+{
+  /* Get the current exceptions.  */
+  _FPU_GETFLAGS (*flagp);
+  *flagp &= excepts;
+
+  /* Success.  */
+  return 0;
+}
--- glibc/sysdeps/riscv/fpu/fraiseexcpt.c
+++ riscv-glibc/sysdeps/riscv/fpu/fraiseexcpt.c
@@ -0,0 +1,32 @@
+/* Raise given exceptions.
+   Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+__feraiseexcept (int excepts)
+{
+  asm volatile ("csrs fflags, %0" : : "r"(excepts));
+  return 0;
+}
+libm_hidden_def (__feraiseexcept)
+weak_alias (__feraiseexcept, feraiseexcept)
+libm_hidden_weak (feraiseexcept)
--- glibc/sysdeps/riscv/fpu/fsetexcptflg.c
+++ riscv-glibc/sysdeps/riscv/fpu/fsetexcptflg.c
@@ -0,0 +1,32 @@
+/* Set floating-point environment exception handling.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Hartvig Ekner <hartvige@mips.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+int
+fesetexceptflag (const fexcept_t *flagp, int excepts)
+{
+  fexcept_t flags = *flagp;
+  asm volatile ("csrc fflags, %0" : : "r"(excepts));
+  asm volatile ("csrs fflags, %0" : : "r"(flags & excepts));
+
+  return 0;
+}
--- glibc/sysdeps/riscv/fpu/ftestexcept.c
+++ riscv-glibc/sysdeps/riscv/fpu/ftestexcept.c
@@ -0,0 +1,29 @@
+/* Test exception in current environment.
+   Copyright (C) 1998, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@arthur.rhein-neckar.de>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fenv.h>
+#include <math_private.h>
+
+int
+fetestexcept (int excepts)
+{
+  return libc_fetestexcept_riscv (excepts);
+}
+libm_hidden_def (fetestexcept)
--- glibc/sysdeps/riscv/fpu/math_private.h
+++ riscv-glibc/sysdeps/riscv/fpu/math_private.h
@@ -0,0 +1,145 @@
+/* Private floating point rounding and exceptions handling.  RISC-V version.
+   Copyright (C) 2014-2015 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef RISCV_MATH_PRIVATE_H
+#define RISCV_MATH_PRIVATE_H 1
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+static __always_inline void
+libc_feholdexcept_riscv (fenv_t *envp)
+{
+  _FPU_GETCW (*envp);
+  _FPU_SETFLAGS (0);
+}
+
+#define libc_feholdexcept  libc_feholdexcept_riscv
+#define libc_feholdexceptf libc_feholdexcept_riscv
+#define libc_feholdexceptl libc_feholdexcept_riscv
+
+static __always_inline void
+libc_fesetround_riscv (int round)
+{
+  _FPU_SETROUND (round);
+}
+
+#define libc_fesetround  libc_fesetround_riscv
+#define libc_fesetroundf libc_fesetround_riscv
+#define libc_fesetroundl libc_fesetround_riscv
+
+static __always_inline void
+libc_feholdexcept_setround_riscv (fenv_t *envp, int round)
+{
+  libc_fesetround_riscv (round);
+  libc_feholdexcept_riscv (envp);
+}
+
+#define libc_feholdexcept_setround  libc_feholdexcept_setround_riscv
+#define libc_feholdexcept_setroundf libc_feholdexcept_setround_riscv
+#define libc_feholdexcept_setroundl libc_feholdexcept_setround_riscv
+
+static __always_inline int
+libc_fetestexcept_riscv (int ex)
+{
+  int cw;
+
+  _FPU_GETFLAGS (cw);
+
+  return cw & ex;
+}
+
+#define libc_fetestexcept  libc_fetestexcept_riscv
+#define libc_fetestexceptf libc_fetestexcept_riscv
+#define libc_fetestexceptl libc_fetestexcept_riscv
+
+static __always_inline void
+libc_fesetenv_riscv (const fenv_t *envp)
+{
+  long env = (long) envp - (long) FE_DFL_ENV;
+  if (env != 0)
+    env = *envp;
+
+  _FPU_SETCW (env);
+}
+
+#define libc_fesetenv  libc_fesetenv_riscv
+#define libc_fesetenvf libc_fesetenv_riscv
+#define libc_fesetenvl libc_fesetenv_riscv
+#define libc_feresetround_noex  libc_fesetenv_riscv
+#define libc_feresetround_noexf libc_fesetenv_riscv
+#define libc_feresetround_noexl libc_fesetenv_riscv
+
+static __always_inline int
+libc_feupdateenv_test_riscv (const fenv_t *envp, int ex)
+{
+  fenv_t env = *envp;
+  int excepts;
+
+  _FPU_SETROUND (0);
+  asm volatile ("csrrs %0, fcsr, %1" : "=r"(excepts) : "r"(env));
+
+  return excepts & ex;
+}
+
+#define libc_feupdateenv_test  libc_feupdateenv_test_riscv
+#define libc_feupdateenv_testf libc_feupdateenv_test_riscv
+#define libc_feupdateenv_testl libc_feupdateenv_test_riscv
+
+static __always_inline void
+libc_feupdateenv_riscv (const fenv_t *envp)
+{
+  fenv_t env = *envp;
+
+  _FPU_SETROUND (0);
+  asm volatile ("csrs fcsr, %0" : : "r"(env));
+}
+
+#define libc_feupdateenv  libc_feupdateenv_riscv
+#define libc_feupdateenvf libc_feupdateenv_riscv
+#define libc_feupdateenvl libc_feupdateenv_riscv
+
+static __always_inline void
+libc_feholdsetround_riscv (fenv_t *envp, int round)
+{
+  /* Note this implementation makes an improperly-formatted fenv_t and
+     so should only be used in conjunction with libc_feresetround.  */
+  int old_round;
+  asm volatile ("csrrw %0, frm, %1" : "=r"(old_round) : "r"(round));
+  *envp = old_round;
+}
+
+#define libc_feholdsetround  libc_feholdsetround_riscv
+#define libc_feholdsetroundf libc_feholdsetround_riscv
+#define libc_feholdsetroundl libc_feholdsetround_riscv
+
+static __always_inline void
+libc_feresetround_riscv (fenv_t *envp)
+{
+  /* Note this implementation takes an improperly-formatted fenv_t and
+     so should only be used in conjunction with libc_feholdsetround.  */
+  _FPU_SETROUND (*envp);
+}
+
+#define libc_feresetround  libc_feresetround_riscv
+#define libc_feresetroundf libc_feresetround_riscv
+#define libc_feresetroundl libc_feresetround_riscv
+
+#include_next <math_private.h>
+
+#endif
--- glibc/sysdeps/riscv/fpu/s_copysign.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_copysign.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+double __copysign(double x, double y)
+{
+  double res;
+  asm ("fsgnj.d %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__copysign, copysign)
--- glibc/sysdeps/riscv/fpu/s_copysignf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_copysignf.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+float __copysignf(float x, float y)
+{
+  float res;
+  asm ("fsgnj.s %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+}
+weak_alias (__copysignf, copysignf)
--- glibc/sysdeps/riscv/fpu/s_fabs.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fabs.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+double __fabs(double x)
+{
+  double res;
+  asm ("fabs.d %0, %1" : "=f"(res) : "f"(x));
+  return res;
+}
+weak_alias (__fabs, fabs)
--- glibc/sysdeps/riscv/fpu/s_fabsf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fabsf.c
@@ -0,0 +1,9 @@
+#include "math.h"
+
+float __fabsf(float x)
+{
+  float res;
+  asm ("fabs.s %0, %1" : "=f"(res) : "f"(x));
+  return res;
+}
+weak_alias (__fabsf, fabsf)
--- glibc/sysdeps/riscv/fpu/s_fdim.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fdim.c
@@ -0,0 +1,22 @@
+#include <errno.h>
+#include <math.h>
+#include "fpu_control.h"
+
+double __fdim (double x, double y)
+{
+  double diff = x - y;
+  
+  if (x <= y)
+    return 0.0;
+
+#ifdef __riscv_soft_float
+  if (isinf(diff))
+    errno = ERANGE;
+#else
+  if (__builtin_expect(_FCLASS(diff) & _FCLASS_INF, 0))
+    errno = ERANGE;
+#endif
+
+  return diff;
+}
+weak_alias (__fdim, fdim)
--- glibc/sysdeps/riscv/fpu/s_fdimf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fdimf.c
@@ -0,0 +1,22 @@
+#include <errno.h>
+#include <math.h>
+#include "fpu_control.h"
+
+float __fdimf (float x, float y)
+{
+  float diff = x - y;
+  
+  if (x <= y)
+    return 0.0f;
+
+#ifdef __riscv_soft_float
+  if (isinf(diff))
+    errno = ERANGE;
+#else
+  if (__builtin_expect(_FCLASS(diff) & _FCLASS_INF, 0))
+    errno = ERANGE;
+#endif
+
+  return diff;
+}
+weak_alias (__fdimf, fdimf)
--- glibc/sysdeps/riscv/fpu/s_finite.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_finite.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __finite(double x)
+{
+  return _FCLASS(x) & ~(_FCLASS_INF | _FCLASS_NAN);
+}
+hidden_def (__finite)
+weak_alias (__finite, finite)
--- glibc/sysdeps/riscv/fpu/s_finitef.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_finitef.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __finitef(float x)
+{
+  return _FCLASS(x) & ~(_FCLASS_INF | _FCLASS_NAN);
+}
+hidden_def (__finitef)
+weak_alias (__finitef, finitef)
--- glibc/sysdeps/riscv/fpu/s_fma.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fma.c
@@ -0,0 +1,11 @@
+#include <math.h>
+#include <fenv.h>
+#include <ieee754.h>
+
+double __fma (double x, double y, double z)
+{
+  double out;
+  asm volatile ("fmadd.d %0, %1, %2, %3" : "=f"(out) : "f"(x), "f"(y), "f"(z));
+  return out;
+}
+weak_alias (__fma, fma)
--- glibc/sysdeps/riscv/fpu/s_fmaf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fmaf.c
@@ -0,0 +1,11 @@
+#include <math.h>
+#include <fenv.h>
+#include <ieee754.h>
+
+float __fmaf (float x, float y, float z)
+{
+  float out;
+  asm volatile ("fmadd.s %0, %1, %2, %3" : "=f"(out) : "f"(x), "f"(y), "f"(z));
+  return out;
+}
+weak_alias (__fmaf, fmaf)
--- glibc/sysdeps/riscv/fpu/s_fmax.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fmax.c
@@ -0,0 +1,17 @@
+#include <math.h>
+
+double __fmax (double x, double y)
+{
+#ifdef __riscv_soft_float
+  if (isnan(x))
+    return y;
+  if (isnan(y))
+    return x;
+  return (x > y) ? x : y;
+#else
+  double res;
+  asm ("fmax.d %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+#endif
+}
+weak_alias (__fmax, fmax)
--- glibc/sysdeps/riscv/fpu/s_fmaxf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fmaxf.c
@@ -0,0 +1,17 @@
+#include <math.h>
+
+float __fmaxf (float x, float y)
+{
+#ifdef __riscv_soft_float
+  if (isnan(x))
+    return y;
+  if (isnan(y))
+    return x;
+  return (x > y) ? x : y;
+#else
+  float res;
+  asm ("fmax.s %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+#endif
+}
+weak_alias (__fmaxf, fmaxf)
--- glibc/sysdeps/riscv/fpu/s_fmin.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fmin.c
@@ -0,0 +1,17 @@
+#include <math.h>
+
+double __fmin (double x, double y)
+{
+#ifdef __riscv_soft_float
+  if (isnan(x))
+      return y;
+  if (isnan(y))
+      return x;
+  return (x < y) ? x : y;
+#else
+  double res;
+  asm ("fmin.d %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+#endif
+}
+weak_alias (__fmin, fmin)
--- glibc/sysdeps/riscv/fpu/s_fminf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fminf.c
@@ -0,0 +1,17 @@
+#include <math.h>
+
+float __fminf (float x, float y)
+{
+#ifdef __riscv_soft_float
+  if (isnan(x))
+    return y;
+  if (isnan(y))
+    return x;
+  return (x < y) ? x : y;
+#else
+  float res;
+  asm ("fmin.s %0, %1, %2" : "=f"(res) : "f"(x), "f"(y));
+  return res;
+#endif
+}
+weak_alias (__fminf, fminf)
--- glibc/sysdeps/riscv/fpu/s_fpclassify.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fpclassify.c
@@ -0,0 +1,18 @@
+#include <math.h>
+#include "fpu_control.h"
+#include "math_private.h"
+
+int __fpclassify (double x)
+{
+  int cls = _FCLASS(x);
+  if (__builtin_expect(cls & _FCLASS_NORM, _FCLASS_NORM))
+    return FP_NORMAL;
+  if (__builtin_expect(cls & _FCLASS_ZERO, _FCLASS_ZERO))
+    return FP_ZERO;
+  if (__builtin_expect(cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))
+    return FP_SUBNORMAL;
+  if (__builtin_expect(cls & _FCLASS_INF, _FCLASS_INF))
+    return FP_INFINITE;
+  return FP_NAN;
+}
+libm_hidden_def (__fpclassify)
--- glibc/sysdeps/riscv/fpu/s_fpclassifyf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_fpclassifyf.c
@@ -0,0 +1,18 @@
+#include <math.h>
+#include "fpu_control.h"
+#include "math_private.h"
+
+int __fpclassifyf (float x)
+{
+  int cls = _FCLASS(x);
+  if (__builtin_expect(cls & _FCLASS_NORM, _FCLASS_NORM))
+    return FP_NORMAL;
+  if (__builtin_expect(cls & _FCLASS_ZERO, _FCLASS_ZERO))
+    return FP_ZERO;
+  if (__builtin_expect(cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))
+    return FP_SUBNORMAL;
+  if (__builtin_expect(cls & _FCLASS_INF, _FCLASS_INF))
+    return FP_INFINITE;
+  return FP_NAN;
+}
+libm_hidden_def (__fpclassifyf)
--- glibc/sysdeps/riscv/fpu/s_isinf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_isinf.c
@@ -0,0 +1,10 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isinf(double x)
+{
+  int cls = _FCLASS(x);
+  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);
+}
+hidden_def (__isinf)
+weak_alias (__isinf, isinf)
--- glibc/sysdeps/riscv/fpu/s_isinff.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_isinff.c
@@ -0,0 +1,10 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isinff(float x)
+{
+  int cls = _FCLASS(x);
+  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);
+}
+hidden_def (__isinff)
+weak_alias (__isinff, isinff)
--- glibc/sysdeps/riscv/fpu/s_isnan.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_isnan.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isnan(double x)
+{
+  return _FCLASS(x) & _FCLASS_NAN;
+}
+hidden_def (__isnan)
+weak_alias (__isnan, isnan)
--- glibc/sysdeps/riscv/fpu/s_isnanf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_isnanf.c
@@ -0,0 +1,9 @@
+#include "math.h"
+#include "fpu_control.h"
+
+int __isnanf(float x)
+{
+  return _FCLASS(x) & _FCLASS_NAN;
+}
+hidden_def (__isnanf)
+weak_alias (__isnanf, isnanf)
--- glibc/sysdeps/riscv/fpu/s_signbit.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_signbit.c
@@ -0,0 +1,18 @@
+#include <features.h>
+#undef __USE_EXTERN_INLINES
+#include <math.h>
+#include <stdint.h>
+#include "math_private.h"
+
+int __signbit (double x)
+{
+#ifdef __riscv64
+  int64_t hx;
+  EXTRACT_WORDS64 (hx, x);
+  return hx < 0;
+#else
+  int32_t hx;
+  GET_HIGH_WORD (hx, x);
+  return hx < 0;
+#endif
+}
--- glibc/sysdeps/riscv/fpu/s_signbitf.c
+++ riscv-glibc/sysdeps/riscv/fpu/s_signbitf.c
@@ -0,0 +1,12 @@
+#include <features.h>
+#undef __USE_EXTERN_INLINES
+#include <math.h>
+#include <stdint.h>
+#include "math_private.h"
+
+int __signbitf (float x)
+{
+  int32_t hx;
+  GET_FLOAT_WORD (hx, x);
+  return hx < 0;
+}
--- glibc/sysdeps/riscv/fpu_control.h
+++ riscv-glibc/sysdeps/riscv/fpu_control.h
@@ -0,0 +1,84 @@
+/* FPU control word bits.  Mips version.
+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2006, 2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Olaf Flebbe and Ralf Baechle.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+
+#include <features.h>
+
+#ifdef __riscv_soft_float
+
+#define _FPU_RESERVED 0xffffffff
+#define _FPU_DEFAULT  0x00000000
+typedef unsigned int fpu_control_t;
+#define _FPU_GETCW(cw) (cw) = 0
+#define _FPU_GETROUND(cw) (cw) = 0
+#define _FPU_GETFLAGS(cw) (cw) = 0
+#define _FPU_SETCW(cw) do { } while (0)
+#define _FPU_SETROUND(cw) do { } while (0)
+#define _FPU_SETFLAGS(cw) do { } while (0)
+extern fpu_control_t __fpu_control;
+
+#else /* __riscv_soft_float */
+
+#define _FPU_RESERVED 0
+#define _FPU_DEFAULT  0
+#define _FPU_IEEE     _FPU_DEFAULT
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__SI__)));
+
+/* Macros for accessing the hardware control word.  */
+#define _FPU_GETCW(cw) __asm__ volatile ("frsr %0" : "=r" (cw))
+#define _FPU_GETROUND(cw) __asm__ volatile ("frrm %0" : "=r" (cw))
+#define _FPU_GETFLAGS(cw) __asm__ volatile ("frflags %0" : "=r" (cw))
+#define _FPU_SETCW(cw) __asm__ volatile ("fssr %z0" : : "rJ" (cw))
+#define _FPU_SETROUND(cw) __asm__ volatile ("fsrm %z0" : : "rJ" (cw))
+#define _FPU_SETFLAGS(cw) __asm__ volatile ("fsflags %z0" : : "rJ" (cw))
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#define _FCLASS(x) ({ int res; \
+  if (sizeof(x) == 4) asm ("fclass.s %0, %1" : "=r"(res) : "f"(x)); \
+  else if (sizeof(x) == 8) asm ("fclass.d %0, %1" : "=r"(res) : "f"(x)); \
+  else abort(); \
+  res; })
+
+#define _FCLASS_MINF     (1<<0)
+#define _FCLASS_MNORM    (1<<1)
+#define _FCLASS_MSUBNORM (1<<2)
+#define _FCLASS_MZERO    (1<<3)
+#define _FCLASS_PZERO    (1<<4)
+#define _FCLASS_PSUBNORM (1<<5)
+#define _FCLASS_PNORM    (1<<6)
+#define _FCLASS_PINF     (1<<7)
+#define _FCLASS_SNAN     (1<<8)
+#define _FCLASS_QNAN     (1<<9)
+#define _FCLASS_ZERO     (_FCLASS_MZERO | _FCLASS_PZERO)
+#define _FCLASS_SUBNORM  (_FCLASS_MSUBNORM | _FCLASS_PSUBNORM)
+#define _FCLASS_NORM     (_FCLASS_MNORM | _FCLASS_PNORM)
+#define _FCLASS_INF      (_FCLASS_MINF | _FCLASS_PINF)
+#define _FCLASS_NAN      (_FCLASS_SNAN | _FCLASS_QNAN)
+
+#endif /* __riscv_soft_float */
+
+#endif	/* fpu_control.h */
--- glibc/sysdeps/riscv/gccframe.h
+++ riscv-glibc/sysdeps/riscv/gccframe.h
@@ -0,0 +1,22 @@
+/* Definition of object in frame unwind info.  mips version.
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define FIRST_PSEUDO_REGISTER 76
+
+#include <sysdeps/generic/gccframe.h>
--- glibc/sysdeps/riscv/get-rounding-mode.h
+++ riscv-glibc/sysdeps/riscv/get-rounding-mode.h
@@ -0,0 +1,38 @@
+/* Determine floating-point rounding mode within libc.  RISC-V version.
+
+   Copyright (C) 2015 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _RISCV_GET_ROUNDING_MODE_H
+#define _RISCV_GET_ROUNDING_MODE_H
+
+#include <fenv.h>
+#include <fpu_control.h>
+
+/* Return the floating-point rounding mode.  */
+
+static inline int
+get_rounding_mode (void)
+{
+  fpu_control_t fpcr;
+
+  _FPU_GETROUND (fpcr);
+  return fpcr;
+}
+
+#endif /* get-rounding-mode.h */
--- glibc/sysdeps/riscv/ieee754.h
+++ riscv-glibc/sysdeps/riscv/ieee754.h
@@ -0,0 +1,325 @@
+/* Copyright (C) 1992, 1995, 1996, 1999, 2002, 2003
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _IEEE754_H
+
+#define _IEEE754_H 1
+#include <features.h>
+
+#include <endian.h>
+
+#include <float.h>
+
+__BEGIN_DECLS
+
+union ieee754_float
+  {
+    float f;
+
+    /* This is the IEEE 754 single-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int mantissa:23;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:23;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:8;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa:22;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int mantissa:22;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:8;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee_nan;
+  };
+
+#define IEEE754_FLOAT_BIAS	0x7f /* Added to exponent.  */
+
+
+union ieee754_double
+  {
+    double d;
+
+    /* This is the IEEE 754 double-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:20;
+	unsigned int mantissa1:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:19;
+	unsigned int mantissa1:32;
+#else
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE754_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
+
+#if LDBL_MANT_DIG == 113
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 854 quad-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:16;
+	unsigned int mantissa1:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa3:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa3:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:16;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:15;
+	unsigned int mantissa1:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa3:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa3:32;
+	unsigned int mantissa2:32;
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:15;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+#endif				/* Little endian.  */
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS 0x3fff /* Added to exponent.  */
+
+#elif LDBL_MANT_DIG == 64
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:32;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:32;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee;
+
+    /* This is for NaNs in the IEEE 854 double-extended-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:15;
+	unsigned int empty:16;
+	unsigned int one:1;
+	unsigned int quiet_nan:1;
+	unsigned int mantissa0:30;
+	unsigned int mantissa1:32;
+#endif
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int mantissa1:32;
+# else
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:30;
+	unsigned int quiet_nan:1;
+	unsigned int one:1;
+	unsigned int exponent:15;
+	unsigned int negative:1;
+	unsigned int empty:16;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS 0x3fff
+
+#elif LDBL_MANT_DIG == 53
+
+union ieee854_long_double
+  {
+    long double d;
+
+    /* This is the IEEE 754 double-precision format.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:20;
+	unsigned int mantissa1:32;
+#endif				/* Big endian.  */
+#if	__BYTE_ORDER == __LITTLE_ENDIAN
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:20;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif				/* Little endian.  */
+      } ieee;
+
+    /* This format makes it easier to see if a NaN is a signalling NaN.  */
+    struct
+      {
+#if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int negative:1;
+	unsigned int exponent:11;
+	unsigned int quiet_nan:1;
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa0:19;
+	unsigned int mantissa1:32;
+#else
+# if	__FLOAT_WORD_ORDER == __BIG_ENDIAN
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+	unsigned int mantissa1:32;
+# else
+	/* Together these comprise the mantissa.  */
+	unsigned int mantissa1:32;
+	unsigned int mantissa0:19;
+	unsigned int quiet_nan:1;
+	unsigned int exponent:11;
+	unsigned int negative:1;
+# endif
+#endif
+      } ieee_nan;
+  };
+
+#define IEEE854_LONG_DOUBLE_BIAS	0x3ff /* Added to exponent.  */
+
+#endif /* LDBL_MANT_DIG == 53 */
+
+__END_DECLS
+
+#endif /* ieee754.h */
--- glibc/sysdeps/riscv/Implies
+++ riscv-glibc/sysdeps/riscv/Implies
@@ -0,0 +1,4 @@
+init_array
+
+ieee754/flt-32
+ieee754/dbl-64
--- glibc/sysdeps/riscv/jmpbuf-unwind.h
+++ riscv-glibc/sysdeps/riscv/jmpbuf-unwind.h
@@ -0,0 +1,46 @@
+/* Copyright (C) 2003, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+#include <sysdep.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle)		\
+  ((void *) (address) < (void *) demangle ((jmpbuf)[0].__sp))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+static inline uintptr_t __attribute__ ((unused))
+_jmpbuf_sp (__jmp_buf regs)
+{
+  uintptr_t sp = regs[0].__sp;
+#ifdef PTR_DEMANGLE
+  PTR_DEMANGLE (sp);
+#endif
+  return sp;
+}
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < _jmpbuf_sp (_jmpbuf) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
--- glibc/sysdeps/riscv/ldsodefs.h
+++ riscv-glibc/sysdeps/riscv/ldsodefs.h
@@ -0,0 +1,70 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2000, 2002, 2003, 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MIPS_LDSODEFS_H
+#define _MIPS_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_mips_32_regs;
+struct La_mips_32_retval;
+struct La_mips_64_regs;
+struct La_mips_64_retval;
+
+#define ARCH_PLTENTER_MEMBERS						    \
+    Elf32_Addr (*mips_o32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_32_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf32_Addr (*mips_n32_gnu_pltenter) (Elf32_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);		    \
+    Elf64_Addr (*mips_n64_gnu_pltenter) (Elf64_Sym *, unsigned int,	    \
+					 uintptr_t *, uintptr_t *,	    \
+					 const struct La_mips_64_regs *,    \
+					 unsigned int *, const char *name,  \
+					 long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS						    \
+    unsigned int (*mips_o32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_32_regs *,   \
+					  struct La_mips_32_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n32_gnu_pltexit) (Elf32_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);		    \
+    unsigned int (*mips_n64_gnu_pltexit) (Elf64_Sym *, unsigned int,	    \
+					  uintptr_t *, uintptr_t *,	    \
+					  const struct La_mips_64_regs *,   \
+					  struct La_mips_64_retval *,	    \
+					  const char *);
+
+/* The MIPS ABI specifies that the dynamic section has to be read-only.  */
+
+#define DL_RO_DYN_SECTION 1
+
+#include_next <ldsodefs.h>
+
+#endif
--- glibc/sysdeps/riscv/libc-tls.c
+++ riscv-glibc/sysdeps/riscv/libc-tls.c
@@ -0,0 +1,37 @@
+/* Thread-local storage handling in the ELF dynamic linker.  MIPS version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+#if USE_TLS
+
+/* On RISC-V, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + GET_ADDR_OFFSET;
+}
+
+#endif
--- glibc/sysdeps/riscv/linkmap.h
+++ riscv-glibc/sysdeps/riscv/linkmap.h
@@ -0,0 +1,4 @@
+struct link_map_machine
+  {
+    ElfW(Addr) plt; /* Address of .plt */
+  };
--- glibc/sysdeps/riscv/__longjmp.S
+++ riscv-glibc/sysdeps/riscv/__longjmp.S
@@ -0,0 +1,62 @@
+/* Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (__longjmp)
+	REG_L ra,  0*SZREG(a0)
+	REG_L s0,  1*SZREG(a0)
+	REG_L s1,  2*SZREG(a0)
+	REG_L s2,  3*SZREG(a0)
+	REG_L s3,  4*SZREG(a0)
+	REG_L s4,  5*SZREG(a0)
+	REG_L s5,  6*SZREG(a0)
+	REG_L s6,  7*SZREG(a0)
+	REG_L s7,  8*SZREG(a0)
+	REG_L s8,  9*SZREG(a0)
+	REG_L s9, 10*SZREG(a0)
+	REG_L s10,11*SZREG(a0)
+	REG_L s11,12*SZREG(a0)
+	REG_L sp, 13*SZREG(a0)
+
+#ifdef __riscv_hard_float
+	REG_L a3, 15*SZREG(a0)
+
+	fld  fs0, 16*SZREG+ 0*8(a0)
+	fld  fs1, 16*SZREG+ 1*8(a0)
+	fld  fs2, 16*SZREG+ 2*8(a0)
+	fld  fs3, 16*SZREG+ 3*8(a0)
+	fld  fs4, 16*SZREG+ 4*8(a0)
+	fld  fs5, 16*SZREG+ 5*8(a0)
+	fld  fs6, 16*SZREG+ 6*8(a0)
+	fld  fs7, 16*SZREG+ 7*8(a0)
+	fld  fs8, 16*SZREG+ 8*8(a0)
+	fld  fs9, 16*SZREG+ 9*8(a0)
+	fld  fs10,16*SZREG+10*8(a0)
+	fld  fs11,16*SZREG+11*8(a0)
+
+	fssr a3
+#endif
+
+	seqz a0, a1
+	add  a0, a0, a1   # a0 = (a1 == 0) ? 1 : a1
+	ret
+
+END(__longjmp)
--- glibc/sysdeps/riscv/Makefile
+++ riscv-glibc/sysdeps/riscv/Makefile
@@ -0,0 +1,51 @@
+ifneq ($(all-rtld-routines),)
+CFLAGS-rtld.c += -mno-plt
+CFLAGS-dl-load.c += -mno-plt
+CFLAGS-dl-cache.c += -mno-plt
+CFLAGS-dl-lookup.c += -mno-plt
+CFLAGS-dl-object.c += -mno-plt
+CFLAGS-dl-reloc.c += -mno-plt
+CFLAGS-dl-deps.c += -mno-plt
+CFLAGS-dl-runtime.c += -mno-plt
+CFLAGS-dl-error.c += -mno-plt
+CFLAGS-dl-init.c += -mno-plt
+CFLAGS-dl-fini.c += -mno-plt
+CFLAGS-dl-debug.c += -mno-plt
+CFLAGS-dl-misc.c += -mno-plt
+CFLAGS-dl-version.c += -mno-plt
+CFLAGS-dl-profile.c += -mno-plt
+CFLAGS-dl-conflict.c += -mno-plt
+CFLAGS-dl-tls.c += -mno-plt
+CFLAGS-dl-origin.c += -mno-plt
+CFLAGS-dl-scope.c += -mno-plt
+CFLAGS-dl-execstack.c += -mno-plt
+CFLAGS-dl-caller.c += -mno-plt
+CFLAGS-dl-open.c += -mno-plt
+CFLAGS-dl-close.c += -mno-plt
+CFLAGS-dl-sysdep.c += -mno-plt
+CFLAGS-dl-environ.c += -mno-plt
+CFLAGS-dl-minimal.c += -mno-plt
+CFLAGS-dl-static.c += -mno-plt
+CFLAGS-dl-brk.c += -mno-plt
+CFLAGS-dl-sbrk.c += -mno-plt
+CFLAGS-dl-getcwd.c += -mno-plt
+CFLAGS-dl-openat64.c += -mno-plt
+CFLAGS-dl-opendir.c += -mno-plt
+CFLAGS-dl-fxstatat64.c += -mno-plt
+endif
+
+CFLAGS-closedir.c += -mno-plt
+CFLAGS-exit.c += -mno-plt
+CFLAGS-cxa_atexit.c += -mno-plt
+
+ifeq ($(subdir),misc)
+sysdep_headers += sys/asm.h
+endif
+
+ASFLAGS-.os += $(pic-ccflag)
+
+ifneq ($(with-fp),yes)
++cflags += -msoft-float
+ASFLAGS += -msoft-float
+sysdep-LDFLAGS += -msoft-float
+endif
--- glibc/sysdeps/riscv/memcpy.c
+++ riscv-glibc/sysdeps/riscv/memcpy.c
@@ -0,0 +1,68 @@
+#include <string.h>
+#include <stdint.h>
+
+void* __memcpy(void* aa, const void* bb, size_t n)
+{
+  #define BODY(a, b, t) { \
+    t tt = *b; \
+    a++, b++; \
+    *(a-1) = tt; \
+  }
+
+  char* a = (char*)aa;
+  const char* b = (const char*)bb;
+  char* end = a+n;
+  uintptr_t msk = sizeof(long)-1;
+  if (__builtin_expect(((uintptr_t)a & msk) != ((uintptr_t)b & msk) || n < sizeof(long), 0))
+  {
+small:
+    if (__builtin_expect(a < end, 1))
+      while (a < end)
+        BODY(a, b, char);
+    return aa;
+  }
+
+  if (__builtin_expect(((uintptr_t)a & msk) != 0, 0))
+    while ((uintptr_t)a & msk)
+      BODY(a, b, char);
+
+  long* la = (long*)a;
+  const long* lb = (const long*)b;
+  long* lend = (long*)((uintptr_t)end & ~msk);
+
+  if (__builtin_expect(la < lend-8, 0))
+  {
+    while (la < lend-8)
+    {
+      long b0 = *lb++;
+      long b1 = *lb++;
+      long b2 = *lb++;
+      long b3 = *lb++;
+      long b4 = *lb++;
+      long b5 = *lb++;
+      long b6 = *lb++;
+      long b7 = *lb++;
+      long b8 = *lb++;
+      *la++ = b0;
+      *la++ = b1;
+      *la++ = b2;
+      *la++ = b3;
+      *la++ = b4;
+      *la++ = b5;
+      *la++ = b6;
+      *la++ = b7;
+      *la++ = b8;
+    }
+  }
+
+  while (la < lend)
+    BODY(la, lb, long);
+
+  a = (char*)la;
+  b = (const char*)lb;
+  if (__builtin_expect(a < end, 0))
+    goto small;
+  return aa;
+}
+weak_alias (__memcpy, memcpy)
+libc_hidden_builtin_def (memcpy)
--- glibc/sysdeps/riscv/memset.S
+++ riscv-glibc/sysdeps/riscv/memset.S
@@ -0,0 +1,107 @@
+/* Copyright (C) 2014 Free Software Foundation, Inc.
+   Contributed by Andrew Waterman (waterman@cs.berkeley.edu) at UC Berkeley.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY(memset)
+  li a6, 15
+  move a4, a0
+  bleu a2, a6, .Ltiny
+  and a5, a4, 15
+  bnez a5, .Lmisaligned
+
+.Laligned:
+  bnez a1, .Lwordify
+
+.Lwordified:
+  and a3, a2, ~15
+  and a2, a2, 15
+  add a3, a3, a4
+
+#ifdef __riscv64
+1:sd a1, 0(a4)
+  sd a1, 8(a4)
+#else
+1:sw a1, 0(a4)
+  sw a1, 4(a4)
+  sw a1, 8(a4)
+  sw a1, 12(a4)
+#endif
+  add a4, a4, 16
+  bltu a4, a3, 1b
+
+  bnez a2, .Ltiny
+  ret
+
+.Ltiny:
+  sub a3, a6, a2
+  sll a3, a3, 2
+1:auipc t0, %pcrel_hi(.Ltable)
+  add a3, a3, t0
+.option push
+.option norvc
+.Ltable_misaligned:
+  jr a3, %pcrel_lo(1b)
+.Ltable:
+  sb a1,14(a4)
+  sb a1,13(a4)
+  sb a1,12(a4)
+  sb a1,11(a4)
+  sb a1,10(a4)
+  sb a1, 9(a4)
+  sb a1, 8(a4)
+  sb a1, 7(a4)
+  sb a1, 6(a4)
+  sb a1, 5(a4)
+  sb a1, 4(a4)
+  sb a1, 3(a4)
+  sb a1, 2(a4)
+  sb a1, 1(a4)
+  sb a1, 0(a4)
+.option pop
+  ret
+
+.Lwordify:
+  and a1, a1, 0xFF
+  sll a3, a1, 8
+  or  a1, a1, a3
+  sll a3, a1, 16
+  or  a1, a1, a3
+#ifdef __riscv64
+  sll a3, a1, 32
+  or  a1, a1, a3
+#endif
+  j .Lwordified
+
+.Lmisaligned:
+  sll a3, a5, 2
+1:auipc t0, %pcrel_hi(.Ltable_misaligned)
+  add a3, a3, t0
+  mv t0, ra
+  jalr a3, %pcrel_lo(1b)
+  mv ra, t0
+
+  add a5, a5, -16
+  sub a4, a4, a5
+  add a2, a2, a5
+  bleu a2, a6, .Ltiny
+  j .Laligned
+END(memset)
+
+weak_alias(memset, __GI_memset)
--- glibc/sysdeps/riscv/memusage.h
+++ riscv-glibc/sysdeps/riscv/memusage.h
@@ -0,0 +1,21 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("sp"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
--- glibc/sysdeps/riscv/nptl/bits/pthreadtypes.h
+++ riscv-glibc/sysdeps/riscv/nptl/bits/pthreadtypes.h
@@ -0,0 +1,241 @@
+/* Machine-specific pthread type layouts.  RISC-V version.
+   Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <endian.h>
+
+#ifdef __riscv64
+# define __SIZEOF_PTHREAD_ATTR_T 56
+# define __SIZEOF_PTHREAD_MUTEX_T 40
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 56
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 32
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#else
+# define __SIZEOF_PTHREAD_ATTR_T 36
+# define __SIZEOF_PTHREAD_MUTEX_T 24
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 32
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 20
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#endif
+
+
+/* Thread identifiers.  The structure of the attribute type is
+   deliberately not exposed.  */
+typedef unsigned long int pthread_t;
+
+
+union pthread_attr_t
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+};
+#ifndef __have_pthread_attr_t
+typedef union pthread_attr_t pthread_attr_t;
+# define __have_pthread_attr_t  1
+#endif
+
+#ifdef __riscv64
+typedef struct __pthread_internal_list
+{
+  struct __pthread_internal_list *__prev;
+  struct __pthread_internal_list *__next;
+} __pthread_list_t;
+#else
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+#endif
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is deliberately not exposed.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+#ifdef __riscv64
+    unsigned int __nusers;
+#endif
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+#ifdef __riscv64
+    int __spins;
+    __pthread_list_t __list;
+# define __PTHREAD_MUTEX_HAVE_PREV	1
+#else
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+#endif
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+/* Mutex __spins initializer used by PTHREAD_MUTEX_INITIALIZER.  */
+#define __PTHREAD_SPINS 0
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is deliberately not exposed.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is deliberately not exposed.  */
+typedef union
+{
+# ifdef __riscv64
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+    int __shared;
+    unsigned long int __pad1;
+    unsigned long int __pad2;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+  } __data;
+# else
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+#if __BYTE_ORDER == __BIG_ENDIAN
+    unsigned char __pad1;
+    unsigned char __pad2;
+    unsigned char __shared;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+#else
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+#endif
+    int __writer;
+  } __data;
+# endif
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+#define __PTHREAD_RWLOCK_ELISION_EXTRA 0
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+#ifdef __riscv_atomic
+typedef volatile int pthread_spinlock_t;
+#else
+typedef pthread_mutex_t pthread_spinlock_t;
+#endif
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#endif	/* bits/pthreadtypes.h */
--- glibc/sysdeps/riscv/nptl/bits/semaphore.h
+++ riscv-glibc/sysdeps/riscv/nptl/bits/semaphore.h
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+#ifdef __riscv64
+# define __SIZEOF_SEM_T	32
+#else
+# define __SIZEOF_SEM_T	16
+#endif
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
--- glibc/sysdeps/riscv/nptl/clone.S
+++ riscv-glibc/sysdeps/riscv/nptl/clone.S
@@ -0,0 +1,2 @@
+#define RESET_PID
+#include <sysdeps/unix/sysv/linux/riscv/clone.S>
--- glibc/sysdeps/riscv/nptl/libc-lowlevellock.c
+++ riscv-glibc/sysdeps/riscv/nptl/libc-lowlevellock.c
@@ -0,0 +1,8 @@
+/* This kludge works around a libpthread static linking problem:
+   https://sourceware.org/bugzilla/show_bug.cgi?id=15648 */
+
+#ifndef SHARED
+# define __lll_lock_wait_private weak_function __lll_lock_wait_private
+#endif
+
+#include <lowlevellock.c>
--- glibc/sysdeps/riscv/nptl/Makefile
+++ riscv-glibc/sysdeps/riscv/nptl/Makefile
@@ -0,0 +1,25 @@
+# Copyright (C) 2005 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, write to the Free
+# Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+# 02111-1307 USA.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
+
+ifeq ($(subdir),nptl)
+libpthread-sysdep_routines += nptl-sysdep
+endif
--- glibc/sysdeps/riscv/nptl/nptl-sysdep.c
+++ riscv-glibc/sysdeps/riscv/nptl/nptl-sysdep.c
@@ -0,0 +1,2 @@
+/* Pull in __syscall_error.  */
+#include <sysdep.c>
--- glibc/sysdeps/riscv/nptl/pthreaddef.h
+++ riscv-glibc/sysdeps/riscv/nptl/pthreaddef.h
@@ -0,0 +1,32 @@
+/* Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE	(2 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  */
+#define STACK_ALIGN		16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK	2048
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT		16
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME	__builtin_frame_address (0)
--- glibc/sysdeps/riscv/nptl/pthread_spin_destroy.c
+++ riscv-glibc/sysdeps/riscv/nptl/pthread_spin_destroy.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+
+
+int
+pthread_spin_destroy (pthread_spinlock_t *lock)
+{
+#ifdef __riscv_atomic
+  /* Nothing to do.  */
+  return 0;
+#else
+  return pthread_mutex_destroy(lock);
+#endif
+}
--- glibc/sysdeps/riscv/nptl/pthread_spin_init.c
+++ riscv-glibc/sysdeps/riscv/nptl/pthread_spin_init.c
@@ -0,0 +1,33 @@
+/* pthread_spin_init -- initialize a spin lock.  Generic version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+
+
+int
+pthread_spin_init (pthread_spinlock_t *lock, int pshared)
+{
+#ifdef __riscv_atomic
+  *lock = 0;
+  return 0;
+#else
+  return pthread_mutex_init(lock, NULL);
+#endif
+}
--- glibc/sysdeps/riscv/nptl/pthread_spin_lock.c
+++ riscv-glibc/sysdeps/riscv/nptl/pthread_spin_lock.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+
+int pthread_spin_lock(pthread_spinlock_t* lock)
+{
+#ifdef __riscv_atomic
+  int tmp1, tmp2;
+
+  asm volatile ("\n\
+  1:lw           %0, 0(%2)\n\
+    li           %1, %3\n\
+    bnez         %0, 1b\n\
+    amoswap.w.aq %0, %1, 0(%2)\n\
+    bnez         %0, 1b"
+    : "=&r"(tmp1), "=&r"(tmp2) : "r"(lock), "i"(EBUSY)
+  );
+
+  return tmp1;
+#else
+  return pthread_mutex_lock(lock);
+#endif
+}
--- glibc/sysdeps/riscv/nptl/pthread_spin_trylock.c
+++ riscv-glibc/sysdeps/riscv/nptl/pthread_spin_trylock.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+
+int pthread_spin_trylock(pthread_spinlock_t* lock)
+{
+#ifdef __riscv_atomic
+  int tmp1, tmp2;
+
+  asm volatile ("\n\
+    lw           %0, 0(%2)\n\
+    li           %1, %3\n\
+    bnez         %0, 1f\n\
+    amoswap.w.aq %0, %1, 0(%2)\n\
+  1:"
+    : "=&r"(tmp1), "=&r"(tmp2) : "r"(lock), "i"(EBUSY)
+  );
+
+  return tmp1;
+#else
+  return pthread_mutex_trylock(lock);
+#endif
+}
--- glibc/sysdeps/riscv/nptl/pthread_spin_unlock.c
+++ riscv-glibc/sysdeps/riscv/nptl/pthread_spin_unlock.c
@@ -0,0 +1,33 @@
+/* pthread_spin_unlock -- unlock a spin lock.  Generic version.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include "pthreadP.h"
+#include <atomic.h>
+
+int
+pthread_spin_unlock (pthread_spinlock_t *lock)
+{
+#ifdef __riscv_atomic
+  asm volatile ("amoswap.w.rl x0, x0, 0(%0)" : : "r"(lock));
+  return 0;
+#else
+  return pthread_mutex_unlock(lock);
+#endif
+}
--- glibc/sysdeps/riscv/nptl/pt-vfork.S
+++ riscv-glibc/sysdeps/riscv/nptl/pt-vfork.S
@@ -0,0 +1,36 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include "tcb-offsets.h"
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	lw	t0, PID_OFFSET(tp);	/* Load the saved PID.  */	\
+	neg	t0, t0;			/* Negate it.  */		\
+	sw	t0, PID_OFFSET(tp);	/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	a0, 1f;			/* If we are the parent... */	\
+	lw	t0, PID_OFFSET(tp);	/* Load the saved PID.  */	\
+	neg	t0, t0;			/* Re-negate it.  */		\
+	sw	t0, PID_OFFSET(tp);	/* Restore the PID.  */		\
+1:
+
+#include <sysdeps/unix/sysv/linux/riscv/vfork.S>
--- glibc/sysdeps/riscv/nptl/sysdep-cancel.h
+++ riscv-glibc/sysdeps/riscv/nptl/sysdep-cancel.h
@@ -0,0 +1,129 @@
+/* Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sysdeps/generic/sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <nptl/pthreadP.h>
+#endif
+#include <sys/asm.h>
+
+/* Gas will put the initial save of $gp into the CIE, because it appears to
+   happen before any instructions.  So we use cfi_same_value instead of
+   cfi_restore.  */
+
+#if IS_IN (libc) || IS_IN (libpthread) || IS_IN (librt)
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				\
+      .align 2;								\
+  L(pseudo_start):							\
+  99: j __syscall_error;						\
+  ENTRY (name)								\
+    SINGLE_THREAD_P(t0);						\
+    bnez t0, L(pseudo_cancel);  					\
+  .type __##syscall_name##_nocancel, @function;				\
+  .globl __##syscall_name##_nocancel;					\
+  __##syscall_name##_nocancel:						\
+    li a7, SYS_ify(syscall_name);					\
+    scall;								\
+    bltz a0, 99b;							\
+    ret;								\
+  .size __##syscall_name##_nocancel,.-__##syscall_name##_nocancel;	\
+  L(pseudo_cancel):							\
+    addi sp, sp, -STKSPACE;						\
+    REG_S ra, STKOFF_RA(sp);						\
+    cfi_rel_offset (ra, STKOFF_RA);					\
+    PUSHARGS_##args;			/* save syscall args */		\
+    CENABLE;								\
+    REG_S a0, STKOFF_SVMSK(sp);		/* save mask */			\
+    POPARGS_##args;			/* restore syscall args */	\
+    li a7, SYS_ify (syscall_name);					\
+    scall;								\
+    REG_S a0, STKOFF_A0(sp);		/* save syscall result */	\
+    REG_L a0, STKOFF_SVMSK(sp);		/* pass mask as arg1 */		\
+    CDISABLE;								\
+    REG_L ra, STKOFF_RA(sp);		/* restore return address */	\
+    REG_L a0, STKOFF_A0(sp);		/* restore syscall result */	\
+    addi sp, sp, STKSPACE;						\
+    bltz a0, 99b;							\
+  L(pseudo_end):
+
+
+# define PUSHARGS_0	/* nothing to do */
+# define PUSHARGS_1	PUSHARGS_0 REG_S a0, STKOFF_A0(sp); cfi_rel_offset (a0, STKOFF_A0);
+# define PUSHARGS_2	PUSHARGS_1 REG_S a1, STKOFF_A1(sp); cfi_rel_offset (a1, STKOFF_A1);
+# define PUSHARGS_3	PUSHARGS_2 REG_S a2, STKOFF_A2(sp); cfi_rel_offset (a2, STKOFF_A2);
+# define PUSHARGS_4	PUSHARGS_3 REG_S a3, STKOFF_A3(sp); cfi_rel_offset (a3, STKOFF_A3);
+# define PUSHARGS_5	PUSHARGS_4 REG_S a4, STKOFF_A4(sp); cfi_rel_offset (a4, STKOFF_A4);
+# define PUSHARGS_6	PUSHARGS_5 REG_S a5, STKOFF_A5(sp); cfi_rel_offset (a5, STKOFF_A5);
+
+# define POPARGS_0	/* nothing to do */
+# define POPARGS_1	POPARGS_0 REG_L a0, STKOFF_A0(sp);
+# define POPARGS_2	POPARGS_1 REG_L a1, STKOFF_A1(sp);
+# define POPARGS_3	POPARGS_2 REG_L a2, STKOFF_A2(sp);
+# define POPARGS_4	POPARGS_3 REG_L a3, STKOFF_A3(sp);
+# define POPARGS_5	POPARGS_4 REG_L a4, STKOFF_A4(sp);
+# define POPARGS_6	POPARGS_5 REG_L a5, STKOFF_A5(sp);
+
+/* Avoid D$ misses by keeping less-used arguments further down stack.  */
+# define STKOFF_A5	0
+# define STKOFF_A4	(STKOFF_A5 + SZREG)
+# define STKOFF_A3	(STKOFF_A4 + SZREG)
+# define STKOFF_A2	(STKOFF_A3 + SZREG)
+# define STKOFF_A1	(STKOFF_A2 + SZREG)
+# define STKOFF_A0	(STKOFF_A1 + SZREG)
+# define STKOFF_SVMSK	(STKOFF_A0 + SZREG)
+# define STKOFF_RA	(STKOFF_SVMSK + SZREG)
+# define STKSPACE	(STKOFF_RA + SZREG)
+
+# if IS_IN (libpthread)
+#  define CENABLE  call __pthread_enable_asynccancel
+#  define CDISABLE call __pthread_disable_asynccancel
+# elif IS_IN (librt)
+#  define CENABLE  call __librt_enable_asynccancel
+#  define CDISABLE call __librt_disable_asynccancel
+# else
+#  define CENABLE  call __libc_enable_asynccancel
+#  define CDISABLE call __libc_disable_asynccancel
+# endif
+
+# ifndef __ASSEMBLER__
+#  define SINGLE_THREAD_P						\
+	__builtin_expect (THREAD_GETMEM (THREAD_SELF,			\
+					 header.multiple_threads)	\
+			  == 0, 1)
+# else
+#  include "tcb-offsets.h"
+#  define SINGLE_THREAD_P(reg)						\
+	lw reg, MULTIPLE_THREADS_OFFSET(tp)
+#endif
+
+#elif !defined __ASSEMBLER__
+
+# define SINGLE_THREAD_P 1
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+#endif
--- glibc/sysdeps/riscv/nptl/tcb-offsets.sym
+++ riscv-glibc/sysdeps/riscv/nptl/tcb-offsets.sym
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
--- glibc/sysdeps/riscv/nptl/tls.h
+++ riscv-glibc/sysdeps/riscv/nptl/tls.h
@@ -0,0 +1,159 @@
+/* Definition for thread-local data handling.  NPTL/RISC-V version.
+   Copyright (C) 2011-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RISCV_TLS_H
+#define _RISCV_TLS_H	1
+
+#include <dl-sysdep.h>
+
+/* Signal that TLS support is available.  */
+#define USE_TLS	1
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+register void* __thread_self asm("tp");
+# define READ_THREAD_POINTER() ({ __thread_self; })
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the thread blocks.  */
+# define TLS_DTV_AT_TP	1
+# define TLS_TCB_AT_TP	0
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+typedef struct
+{
+  dtv_t *dtv;
+  void *private;
+} tcbhead_t;
+
+/* This is the size of the initial TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_INIT_TCB_SIZE	0
+
+/* Alignment requirements for the initial TCB.  */
+# define TLS_INIT_TCB_ALIGN	__alignof__ (struct pthread)
+
+/* This is the size of the TCB.  Because our TCB is before the thread
+   pointer, we don't need this.  */
+# define TLS_TCB_SIZE		0
+
+/* Alignment requirements for the TCB.  */
+# define TLS_TCB_ALIGN		__alignof__ (struct pthread)
+
+/* This is the size we need before TCB - actually, it includes the TCB.  */
+# define TLS_PRE_TCB_SIZE \
+  (sizeof (struct pthread)						      \
+   + ((sizeof (tcbhead_t) + TLS_TCB_ALIGN - 1) & ~(TLS_TCB_ALIGN - 1)))
+
+/* The thread pointer tp points to the end of the TCB.
+   The pthread_descr structure is immediately in front of the TCB. */
+# define TLS_TCB_OFFSET	0
+
+/* Install the dtv pointer.  The pointer passed is to the element with
+   index -1 which contain the length.  */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread.  */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))[-1].dtv)
+
+/* Code to initially initialize the thread pointer. */
+# define TLS_INIT_TP(tcbp) \
+  ({ __thread_self = (char*)tcbp + TLS_TCB_OFFSET; NULL; })
+
+/* Return the address of the dtv for the current thread.  */
+# define THREAD_DTV() \
+  (((tcbhead_t *) (READ_THREAD_POINTER () - TLS_TCB_OFFSET))[-1].dtv)
+
+/* Return the thread descriptor for the current thread.  */
+# define THREAD_SELF \
+ ((struct pthread *) (READ_THREAD_POINTER ()			     \
+		      - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE))
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+# define TLS_DEFINE_INIT_TP(tp, pd) \
+  void *tp = (void *) (pd) + TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  CONST_THREAD_AREA (32, TLS_TCB_OFFSET + TLS_PRE_TCB_SIZE)
+
+/* Access to data in the thread descriptor is easy.  */
+# define THREAD_GETMEM(descr, member) \
+  descr->member
+# define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+# define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+# define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+/* l_tls_offset == 0 is perfectly valid, so we have to use some different
+   value to mean unset l_tls_offset.  */
+# define NO_TLS_OFFSET		-1
+
+/* Get and set the global scope generation counter in struct pthread.  */
+# define THREAD_GSCOPE_FLAG_UNUSED 0
+# define THREAD_GSCOPE_FLAG_USED   1
+# define THREAD_GSCOPE_FLAG_WAIT   2
+# define THREAD_GSCOPE_RESET_FLAG() \
+  do									     \
+    { int __res								     \
+	= atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,	     \
+			       THREAD_GSCOPE_FLAG_UNUSED);		     \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)				     \
+	lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }									     \
+  while (0)
+# define THREAD_GSCOPE_SET_FLAG() \
+  do									     \
+    {									     \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;	     \
+      atomic_write_barrier ();						     \
+    }									     \
+  while (0)
+# define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
--- glibc/sysdeps/riscv/nptl/vfork.S
+++ riscv-glibc/sysdeps/riscv/nptl/vfork.S
@@ -0,0 +1,41 @@
+/* Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <tls.h>
+#include "tcb-offsets.h"
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	lw	t0, PID_OFFSET(tp);		/* Load the saved PID.  */	\
+	neg	t0, t0;				/* Negate it.  */		\
+	bnez	t0, 1f;				/* If it was zero... */		\
+	li	t0, 0x80000000;			/* use 0x80000000 instead.  */	\
+1:	sw	t0, PID_OFFSET(tp);		/* Store the temporary PID.  */
+
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID \
+	beqz	a0, 1f;				/* If we are the parent... */	\
+	lw	t0, PID_OFFSET(tp);		/* Load the saved PID.  */	\
+	neg	t0, t0;			 	/* Re-negate it.  */		\
+	li	t1, 0x80000000;			/* Load 0x80000000... */	\
+	bne	t0, t1, 2f;			/* ... compare against it... */	\
+	li	t0, 0;				/* ... use 0 instead.  */	\
+2:	sw	t0, PID_OFFSET(tp);		/* Restore the PID.  */		\
+1:
+
+#include <sysdeps/unix/sysv/linux/riscv/vfork.S>
--- glibc/sysdeps/riscv/preconfigure
+++ riscv-glibc/sysdeps/riscv/preconfigure
@@ -0,0 +1,28 @@
+case "$machine" in
+riscv32*)	base_machine=riscv machine=riscv/rv32
+		machine=$machine/$config_machine
+		;;
+riscv*)
+		case "$CC $CFLAGS $CPPFLAGS " in
+		*" -m32 "*) riscv_cc_abi=32 ;;
+		*" -m64 "*) riscv_cc_abi=64 ;;
+		*) riscv_cc_abi=default ;;
+		esac
+		case $config_os in
+		*64*) riscv_config_abi=64 ;;
+		*32*) riscv_config_abi=32 ;;
+		*) riscv_config_abi=$riscv_cc_abi ;;
+		esac
+		case $riscv_config_abi in
+		default) base_machine=riscv machine=riscv/rv64 ;;
+		32) base_machine=riscv machine=riscv/rv32 ;;
+		64) base_machine=riscv machine=riscv/rv64 ;;
+		esac
+		machine=$machine/$config_machine
+		if test $riscv_config_abi != $riscv_cc_abi; then
+		  # This won't make it to config.make, but we want to
+		  # set this in case configure tests depend on it.
+		  CPPFLAGS="$CPPFLAGS -m$riscv_config_abi"
+		fi
+		;;
+esac
--- glibc/sysdeps/riscv/rv32/Implies
+++ riscv-glibc/sysdeps/riscv/rv32/Implies
@@ -0,0 +1,2 @@
+riscv
+wordsize-32
--- glibc/sysdeps/riscv/rv32/Makefile
+++ riscv-glibc/sysdeps/riscv/rv32/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(filter -m32,$(CC)),)
+CC += -m32
+endif
--- glibc/sysdeps/riscv/rv64/gmp-mparam.h
+++ riscv-glibc/sysdeps/riscv/rv64/gmp-mparam.h
@@ -0,0 +1,31 @@
+/* gmp-mparam.h -- Compiler/machine parameter header file.
+
+Copyright (C) 1991, 1993, 1994, 2002, 2003 Free Software Foundation, Inc.
+
+This file is part of the GNU MP Library.
+
+The GNU MP Library is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or (at your
+option) any later version.
+
+The GNU MP Library is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if defined __GMP_H__ && ! defined _LONG_LONG_LIMB
+#error "Included too late for _LONG_LONG_LIMB to take effect"
+#endif
+
+#define _LONG_LONG_LIMB
+#define BITS_PER_MP_LIMB 64
+#define BYTES_PER_MP_LIMB 8
+#define BITS_PER_LONGINT __WORDSIZE
+#define BITS_PER_INT 32
+#define BITS_PER_SHORTINT 16
+#define BITS_PER_CHAR 8
--- glibc/sysdeps/riscv/rv64/Implies
+++ riscv-glibc/sysdeps/riscv/rv64/Implies
@@ -0,0 +1,6 @@
+ieee754/flt-32
+ieee754/dbl-64
+riscv/rv64/soft-fp
+riscv/rv64
+riscv
+wordsize-64
--- glibc/sysdeps/riscv/rv64/Makefile
+++ riscv-glibc/sysdeps/riscv/rv64/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(filter -m64,$(CC)),)
+CC += -m64
+endif
--- glibc/sysdeps/riscv/rv64/soft-fp/Makefile
+++ riscv-glibc/sysdeps/riscv/rv64/soft-fp/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(subdir),math)
+CPPFLAGS += -I../soft-fp
+endif
--- glibc/sysdeps/riscv/rv64/soft-fp/sfp-machine.h
+++ riscv-glibc/sysdeps/riscv/rv64/soft-fp/sfp-machine.h
@@ -0,0 +1,74 @@
+#include <fenv.h>
+#include <fpu_control.h>
+
+#define _FP_W_TYPE_SIZE		64
+#define _FP_W_TYPE		unsigned long long
+#define _FP_WS_TYPE		signed long long
+#define _FP_I_TYPE		long long
+
+#define _FP_MUL_MEAT_S(R,X,Y)					\
+  _FP_MUL_MEAT_1_imm(_FP_WFRACBITS_S,R,X,Y)
+#define _FP_MUL_MEAT_D(R,X,Y)					\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)					\
+  _FP_MUL_MEAT_2_wide_3mul(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_imm(S,R,X,Y,_FP_DIV_HELP_imm)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_2_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1)
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define _FP_DECL_EX		fpu_control_t _fcw
+
+#define FP_ROUNDMODE		(_fcw >> 5)
+
+#define FP_RND_NEAREST		FE_TONEAREST
+#define FP_RND_ZERO		FE_TOWARDZERO
+#define FP_RND_PINF		FE_UPWARD
+#define FP_RND_MINF		FE_DOWNWARD
+
+#define FP_EX_INVALID		FE_INVALID
+#define FP_EX_OVERFLOW		FE_OVERFLOW
+#define FP_EX_UNDERFLOW		FE_UNDERFLOW
+#define FP_EX_DIVZERO		FE_DIVBYZERO
+#define FP_EX_INEXACT		FE_INEXACT
+
+#ifdef __mips_hard_float
+#define FP_INIT_ROUNDMODE			\
+do {						\
+  _FPU_GETCW (_fcw);				\
+} while (0)
+
+#define FP_HANDLE_EXCEPTIONS			\
+do {						\
+  if (__builtin_expect (_fex, 0))		\
+    _FPU_SETCW (_fcw | _fex);			\
+} while (0)
+#else
+#define FP_INIT_ROUNDMODE	_fcw = 0 /* no exceptions; FP_RND_NEAREST */
+#endif
--- glibc/sysdeps/riscv/rv64/Versions
+++ riscv-glibc/sysdeps/riscv/rv64/Versions
@@ -0,0 +1,7 @@
+libm {
+  GLIBC_2.1 {
+    # A generic bug got this omitted from other configurations' version
+    # sets, but we always had it.
+    exp2l;
+  }
+}
--- glibc/sysdeps/riscv/setjmp.S
+++ riscv-glibc/sysdeps/riscv/setjmp.S
@@ -0,0 +1,78 @@
+/* Copyright (C) 1996, 1997, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (_setjmp)
+  li	a1, 0
+  j	__sigsetjmp
+END (_setjmp)
+ENTRY (setjmp)
+  li	a1, 1
+  /* Fallthrough */
+END (setjmp)
+ENTRY (__sigsetjmp)
+	REG_S ra,  0*SZREG(a0)
+	REG_S s0,  1*SZREG(a0)
+	REG_S s1,  2*SZREG(a0)
+	REG_S s2,  3*SZREG(a0)
+	REG_S s3,  4*SZREG(a0)
+	REG_S s4,  5*SZREG(a0)
+	REG_S s5,  6*SZREG(a0)
+	REG_S s6,  7*SZREG(a0)
+	REG_S s7,  8*SZREG(a0)
+	REG_S s8,  9*SZREG(a0)
+	REG_S s9, 10*SZREG(a0)
+	REG_S s10,11*SZREG(a0)
+	REG_S s11,12*SZREG(a0)
+	REG_S sp, 13*SZREG(a0)
+
+#ifdef __riscv_hard_float
+	frsr a3
+
+	fsd  fs0, 16*SZREG+ 0*8(a0)
+	fsd  fs1, 16*SZREG+ 1*8(a0)
+	fsd  fs2, 16*SZREG+ 2*8(a0)
+	fsd  fs3, 16*SZREG+ 3*8(a0)
+	fsd  fs4, 16*SZREG+ 4*8(a0)
+	fsd  fs5, 16*SZREG+ 5*8(a0)
+	fsd  fs6, 16*SZREG+ 6*8(a0)
+	fsd  fs7, 16*SZREG+ 7*8(a0)
+	fsd  fs8, 16*SZREG+ 8*8(a0)
+	fsd  fs9, 16*SZREG+ 9*8(a0)
+	fsd  fs10,16*SZREG+10*8(a0)
+	fsd  fs11,16*SZREG+11*8(a0)
+
+	REG_S a3, 15*SZREG(a0)
+#endif
+
+#if !IS_IN (libc) && IS_IN (rtld)
+  /* In ld.so we never save the signal mask.  */
+  li a0, 0
+  ret
+#else
+  /* Make a tail call to __sigjmp_save; it takes the same args.  */
+  j __sigjmp_save
+#endif
+
+
+END(__sigsetjmp)
+
+weak_alias(_setjmp, __GI__setjmp)
--- glibc/sysdeps/riscv/soft-fp/sfp-machine.h
+++ riscv-glibc/sysdeps/riscv/soft-fp/sfp-machine.h
@@ -0,0 +1,47 @@
+#define _FP_W_TYPE_SIZE		32
+#define _FP_W_TYPE		unsigned long
+#define _FP_WS_TYPE		signed long
+#define _FP_I_TYPE		long
+
+#define _FP_MUL_MEAT_S(R,X,Y)				\
+  _FP_MUL_MEAT_1_wide(_FP_WFRACBITS_S,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_D(R,X,Y)				\
+  _FP_MUL_MEAT_2_wide(_FP_WFRACBITS_D,R,X,Y,umul_ppmm)
+#define _FP_MUL_MEAT_Q(R,X,Y)				\
+  _FP_MUL_MEAT_4_wide(_FP_WFRACBITS_Q,R,X,Y,umul_ppmm)
+
+#define _FP_DIV_MEAT_S(R,X,Y)	_FP_DIV_MEAT_1_udiv_norm(S,R,X,Y)
+#define _FP_DIV_MEAT_D(R,X,Y)	_FP_DIV_MEAT_2_udiv(D,R,X,Y)
+#define _FP_DIV_MEAT_Q(R,X,Y)	_FP_DIV_MEAT_4_udiv(Q,R,X,Y)
+
+#define _FP_NANFRAC_S		((_FP_QNANBIT_S << 1) - 1)
+#define _FP_NANFRAC_D		((_FP_QNANBIT_D << 1) - 1), -1
+#define _FP_NANFRAC_Q		((_FP_QNANBIT_Q << 1) - 1), -1, -1, -1
+#define _FP_NANSIGN_S		0
+#define _FP_NANSIGN_D		0
+#define _FP_NANSIGN_Q		0
+
+#define _FP_KEEPNANFRACP 1
+/* From my experiments it seems X is chosen unless one of the
+   NaNs is sNaN,  in which case the result is NANSIGN/NANFRAC.  */
+#define _FP_CHOOSENAN(fs, wc, R, X, Y, OP)			\
+  do {								\
+    if ((_FP_FRAC_HIGH_RAW_##fs(X) |				\
+	 _FP_FRAC_HIGH_RAW_##fs(Y)) & _FP_QNANBIT_##fs)		\
+      {								\
+	R##_s = _FP_NANSIGN_##fs;				\
+        _FP_FRAC_SET_##wc(R,_FP_NANFRAC_##fs);			\
+      }								\
+    else							\
+      {								\
+	R##_s = X##_s;						\
+        _FP_FRAC_COPY_##wc(R,X);				\
+      }								\
+    R##_c = FP_CLS_NAN;						\
+  } while (0)
+
+#define FP_EX_INVALID           (1 << 4)
+#define FP_EX_DIVZERO           (1 << 3)
+#define FP_EX_OVERFLOW          (1 << 2)
+#define FP_EX_UNDERFLOW         (1 << 1)
+#define FP_EX_INEXACT           (1 << 0)
--- glibc/sysdeps/riscv/sotruss-lib.c
+++ riscv-glibc/sysdeps/riscv/sotruss-lib.c
@@ -0,0 +1,51 @@
+/* Override generic sotruss-lib.c to define actual functions for RISC-V.
+   Copyright (C) 2012-2015 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define HAVE_ARCH_PLTENTER
+#define HAVE_ARCH_PLTEXIT
+
+#include <elf/sotruss-lib.c>
+
+ElfW(Addr)
+la_riscv_gnu_pltenter (ElfW(Sym) *sym __attribute__ ((unused)),
+		       unsigned int ndx __attribute__ ((unused)),
+		       uintptr_t *refcook, uintptr_t *defcook,
+		       La_riscv_regs *regs, unsigned int *flags,
+		       const char *symname, long int *framesizep)
+{
+  print_enter (refcook, defcook, symname,
+	       regs->lr_reg[0], regs->lr_reg[1], regs->lr_reg[2],
+	       *flags);
+
+  /* No need to copy anything, we will not need the parameters in any case.  */
+  *framesizep = 0;
+
+  return sym->st_value;
+}
+
+unsigned int
+la_riscv_gnu_pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
+		      uintptr_t *defcook,
+		      const struct La_riscv_regs *inregs,
+		      struct La_riscv_retval *outregs,
+		      const char *symname)
+{
+  print_exit (refcook, defcook, symname, outregs->lrv_a0);
+
+  return 0;
+}
--- glibc/sysdeps/riscv/stackinfo.h
+++ riscv-glibc/sysdeps/riscv/stackinfo.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 2000, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+#include <elf.h>
+
+/* On MIPS the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+/* Default to an executable stack.  PF_X can be overridden if PT_GNU_STACK is
+ * present, but it is presumed absent.  */
+#define DEFAULT_STACK_PERMS (PF_R|PF_W|PF_X)
+
+#endif	/* stackinfo.h */
--- glibc/sysdeps/riscv/start.S
+++ riscv-glibc/sysdeps/riscv/start.S
@@ -0,0 +1,66 @@
+/* Startup code compliant to the ELF Mips ABI.
+   Copyright (C) 1995, 1997, 2000, 2001, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __ASSEMBLY__ 1
+#include <entry.h>
+#include <sysdep.h>
+#include <sys/asm.h>
+
+/* The entry point's job is to call __libc_start_main.  Per the ABI,
+   a0 contains the address of a function to be passed to atexit.
+   __libc_start_main wants this in a5.  */
+
+ENTRY(ENTRY_POINT)
+	lla   gp, _gp
+	move  a5, a0  /* rtld_fini */
+	lla   a0, main
+	REG_L a1, 0(sp)      /* argc */
+	addi  a2, sp, SZREG  /* argv */
+	andi  sp, sp, ALMASK /* Align stack. */
+	lla   a3, __libc_csu_init
+	lla   a4, __libc_csu_fini
+	move  a6, sp  /* stack_end */
+	
+	tail  __libc_start_main@
+END(ENTRY_POINT)
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.weak data_start
+	data_start = __data_start
--- glibc/sysdeps/riscv/strcmp.S
+++ riscv-glibc/sysdeps/riscv/strcmp.S
@@ -0,0 +1,143 @@
+# Artisanally coded in California by A. Shell Waterman
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
+# error
+#endif
+
+ENTRY(strcmp)
+  or    a4, a0, a1
+  li    t2, -1
+  and   a4, a4, SZREG-1
+  bnez  a4, .Lmisaligned
+
+#if SZREG == 4
+  li t3, 0x7f7f7f7f
+#else
+  ld t3, mask
+#endif
+
+  .macro check_one_word i n
+    REG_L a2, \i*SZREG(a0)
+    REG_L a3, \i*SZREG(a1)
+
+    and   t0, a2, t3
+    or    t1, a2, t3
+    add   t0, t0, t3
+    or    t0, t0, t1
+
+    bne   t0, t2, .Lnull\i
+    .if \i+1-\n
+      bne   a2, a3, .Lmismatch
+    .else
+      add   a0, a0, \n*SZREG
+      add   a1, a1, \n*SZREG
+      beq   a2, a3, .Lloop
+      # fall through to .Lmismatch
+    .endif
+  .endm
+
+  .macro foundnull i n
+    .ifne \i
+      .Lnull\i:
+      add   a0, a0, \i*SZREG
+      add   a1, a1, \i*SZREG
+      .ifeq \i-1
+        .Lnull0:
+      .endif
+      bne   a2, a3, .Lmisaligned
+      li    a0, 0
+      ret
+    .endif
+  .endm
+
+.Lloop:
+  # examine full words at a time, favoring strings of a couple dozen chars
+#ifdef __riscv32
+  check_one_word 0 5
+  check_one_word 1 5
+  check_one_word 2 5
+  check_one_word 3 5
+  check_one_word 4 5
+#else
+  check_one_word 0 3
+  check_one_word 1 3
+  check_one_word 2 3
+#endif
+  # backwards branch to .Lloop contained above
+
+.Lmismatch:
+  # words don't match, but a2 has no null byte.
+#ifdef __riscv64
+  sll   a4, a2, 48
+  sll   a5, a3, 48
+  bne   a4, a5, .Lmismatch_upper
+  sll   a4, a2, 32
+  sll   a5, a3, 32
+  bne   a4, a5, .Lmismatch_upper
+#endif
+  sll   a4, a2, 16
+  sll   a5, a3, 16
+  bne   a4, a5, .Lmismatch_upper
+
+  srl   a4, a2, 8*SZREG-16
+  srl   a5, a3, 8*SZREG-16
+  sub   a0, a4, a5
+  and   a1, a0, 0xff
+  bnez  a1, 1f
+  ret
+
+.Lmismatch_upper:
+  srl   a4, a4, 8*SZREG-16
+  srl   a5, a5, 8*SZREG-16
+  sub   a0, a4, a5
+  and   a1, a0, 0xff
+  bnez  a1, 1f
+  ret
+
+1:and   a4, a4, 0xff
+  and   a5, a5, 0xff
+  sub   a0, a4, a5
+  ret
+
+.Lmisaligned:
+  # misaligned
+  lbu   a2, 0(a0)
+  lbu   a3, 0(a1)
+  add   a0, a0, 1
+  add   a1, a1, 1
+  bne   a2, a3, 1f
+  bnez  a2, .Lmisaligned
+
+1:
+  sub   a0, a2, a3
+  ret
+
+  # cases in which a null byte was detected
+#ifdef __riscv32
+  foundnull 0 5
+  foundnull 1 5
+  foundnull 2 5
+  foundnull 3 5
+  foundnull 4 5
+#else
+  foundnull 0 3
+  foundnull 1 3
+  foundnull 2 3
+#endif
+
+END(strcmp)
+
+weak_alias(strcmp, __GI_strcmp)
+
+#if SZREG == 8
+#ifdef __PIC__
+.section .rodata.cst8,"aM",@progbits,8
+#else
+.section .srodata.cst8,"aM",@progbits,8
+#endif
+.align 3
+mask: .8byte 0x7f7f7f7f7f7f7f7f
+#endif
--- glibc/sysdeps/riscv/strcpy.c
+++ riscv-glibc/sysdeps/riscv/strcpy.c
@@ -0,0 +1,54 @@
+#include <string.h>
+#include <stdint.h>
+
+#undef strcpy
+
+char* strcpy(char* dst, const char* src)
+{
+  char* dst0 = dst;
+
+  int misaligned = ((uintptr_t)dst | (uintptr_t)src) & (sizeof(long)-1);
+  if (__builtin_expect(!misaligned, 1))
+  {
+    long* ldst = (long*)dst;
+    const long* lsrc = (const long*)src;
+
+    while (!__libc_detect_null(*lsrc))
+      *ldst++ = *lsrc++;
+
+    dst = (char*)ldst;
+    src = (const char*)lsrc;
+
+    char c0 = src[0];
+    char c1 = src[1];
+    char c2 = src[2];
+    if (!(*dst++ = c0)) return dst0;
+    if (!(*dst++ = c1)) return dst0;
+    char c3 = src[3];
+    if (!(*dst++ = c2)) return dst0;
+    if (sizeof(long) == 4) goto out;
+    char c4 = src[4];
+    if (!(*dst++ = c3)) return dst0;
+    char c5 = src[5];
+    if (!(*dst++ = c4)) return dst0;
+    char c6 = src[6];
+    if (!(*dst++ = c5)) return dst0;
+    if (!(*dst++ = c6)) return dst0;
+
+out:
+    *dst++ = 0;
+    return dst0;
+  }
+
+  char ch;
+  do
+  {
+    ch = *src;
+    src++;
+    dst++;
+    *(dst-1) = ch;
+  } while(ch);
+
+  return dst0;
+}
+libc_hidden_def(strcpy)
--- glibc/sysdeps/riscv/strlen.c
+++ riscv-glibc/sysdeps/riscv/strlen.c
@@ -0,0 +1,38 @@
+#include <string.h>
+#include <stdint.h>
+
+#undef strlen
+
+size_t strlen(const char* str)
+{
+  const char* start = str;
+
+  if (__builtin_expect((uintptr_t)str & (sizeof(long)-1), 0)) do
+  {
+    char ch = *str;
+    str++;
+    if (!ch)
+      return str - start - 1;
+  } while ((uintptr_t)str & (sizeof(long)-1));
+
+  unsigned long* ls = (unsigned long*)str;
+  while (!__libc_detect_null(*ls++))
+    ;
+  asm volatile ("" : "+r"(ls)); /* prevent "optimization" */
+
+  str = (const char*)ls;
+  size_t ret = str - start, sl = sizeof(long);
+
+  char c0 = str[0-sl], c1 = str[1-sl], c2 = str[2-sl], c3 = str[3-sl];
+  if (c0 == 0)            return ret + 0 - sl;
+  if (c1 == 0)            return ret + 1 - sl;
+  if (c2 == 0)            return ret + 2 - sl;
+  if (sl == 4 || c3 == 0) return ret + 3 - sl;
+
+  c0 = str[4-sl], c1 = str[5-sl], c2 = str[6-sl], c3 = str[7-sl];
+  if (c0 == 0)            return ret + 4 - sl;
+  if (c1 == 0)            return ret + 5 - sl;
+  if (c2 == 0)            return ret + 6 - sl;
+  return ret + 7 - sl;
+}
+libc_hidden_def(strlen)
--- glibc/sysdeps/riscv/sys/asm.h
+++ riscv-glibc/sysdeps/riscv/sys/asm.h
@@ -0,0 +1,69 @@
+/* copyright (c) 1997, 1998, 2002, 2003, 2004, 2005
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@gnu.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_ASM_H
+#define _SYS_ASM_H
+
+/* 
+ * Macros to handle different pointer/register sizes for 32/64-bit code
+ */
+#ifdef __riscv64
+# define PTR .dword
+# define PTRLOG 3
+# define SZREG	8
+# define REG_S sd
+# define REG_L ld
+#else
+# define PTR .word
+# define PTRLOG 2
+# define SZREG	4
+# define REG_S sw
+# define REG_L lw
+#endif
+
+/*
+ * LEAF - declare leaf routine
+ */
+#define	LEAF(symbol)				\
+		.globl	symbol;			\
+		.align	2;			\
+		.type	symbol,@function;	\
+symbol:						\
+		cfi_startproc;
+
+/*
+ * NESTED - declare nested routine entry point
+ */
+#define	NESTED(symbol, framesize, rpc) LEAF(symbol)
+
+/*
+ * END - mark end of function
+ */
+#undef END
+#define END(function)				\
+		cfi_endproc;			\
+		.size	function,.-function
+
+/*
+ * Stack alignment
+ */
+#define ALMASK	~15
+
+#endif /* sys/asm.h */
--- glibc/sysdeps/riscv/tcb-offsets.sym
+++ riscv-glibc/sysdeps/riscv/tcb-offsets.sym
@@ -0,0 +1,11 @@
+#include <sysdep.h>
+#include <tls.h>
+
+--
+
+-- Abuse tls.h macros to derive offsets relative to the thread register.
+#define thread_offsetof(mem)	(long)(offsetof(struct pthread, mem) - TLS_TCB_OFFSET - TLS_PRE_TCB_SIZE)
+
+MULTIPLE_THREADS_OFFSET		thread_offsetof (header.multiple_threads)
+PID_OFFSET			thread_offsetof (pid)
+TID_OFFSET			thread_offsetof (tid)
--- glibc/sysdeps/riscv/tst-audit.h
+++ riscv-glibc/sysdeps/riscv/tst-audit.h
@@ -0,0 +1,26 @@
+/* Definitions for testing PLT entry/exit auditing.  ARM version.
+
+   Copyright (C) 2005 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define pltenter la_riscv_gnu_pltenter
+#define pltexit la_riscv_gnu_pltexit
+#define La_regs La_riscv_regs
+#define La_retval La_riscv_retval
+#define int_retval lrv_a0
--- glibc/sysdeps/riscv/Versions
+++ riscv-glibc/sysdeps/riscv/Versions
@@ -0,0 +1,5 @@
+libc {
+  GLIBC_2.14 {
+    __memcpy_g;
+  }
+}
--- glibc/sysdeps/unix/sysv/linux/i386/Makefile
+++ riscv-glibc/sysdeps/unix/sysv/linux/i386/Makefile
@@ -48,11 +48,9 @@ endif
 ifeq ($(subdir),nptl)
 # pull in __syscall_error routine
 libpthread-routines += sysdep
-libpthread-shared-only-routines += sysdep
 endif
 
 ifeq ($(subdir),rt)
 # pull in __syscall_error routine
 librt-routines += sysdep
-librt-shared-only-routines += sysdep
 endif
--- glibc/sysdeps/unix/sysv/linux/riscv/arch-fork.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/arch-fork.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/arch-fork.h>
--- glibc/sysdeps/unix/sysv/linux/riscv/atomic-machine.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/atomic-machine.h
@@ -0,0 +1,53 @@
+/* Low-level functions for atomic operations. RISC-V version.
+   Copyright (C) 2014-2016 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_RISCV_BITS_ATOMIC_H
+#define _LINUX_RISCV_BITS_ATOMIC_H 1
+
+#include_next <atomic-machine.h>
+
+#ifndef __riscv_atomic
+
+#include <sys/syscall.h>
+#include <sysdep.h>
+
+#define __arch_compare_and_exchange_val_8_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+
+#define __arch_compare_and_exchange_val_16_acq(mem, newval, oldval) \
+  (abort (), (__typeof (*mem)) 0)
+
+/* The only basic operation needed is compare and exchange.  */
+#define __arch_compare_and_exchange_val_32_acq(mem, newval, oldval) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    (__typeof (*mem)) INTERNAL_SYSCALL (sysriscv, __err, 4,		      \
+		      RISCV_ATOMIC_CMPXCHG, mem, oldval, newval);	      \
+  })
+
+#define __arch_compare_and_exchange_val_64_acq(mem, newval, oldval) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    (__typeof (*mem)) INTERNAL_SYSCALL (sysriscv, __err, 4,		      \
+		      RISCV_ATOMIC_CMPXCHG64, mem, oldval, newval);	      \
+  })
+
+#endif /* __riscv_atomic */
+
+#endif /* bits/atomic.h */
--- glibc/sysdeps/unix/sysv/linux/riscv/bits/fcntl.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/bits/fcntl.h
@@ -0,0 +1,61 @@
+/* O_*, F_*, FD_* bit values for Linux / RISC-V.
+   Copyright (C) 2016 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+/* In 64-bit ISA files are always with 64bit off_t and F_*LK64 are the same as
+ * non-64-bit versions.  It will need to be revised for 128-bit.  */
+#if __WORDSIZE == 64
+# define __O_LARGEFILE	0
+
+# define F_GETLK64	5	/* Get record locking info.  */
+# define F_SETLK64	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW64	7	/* Set record locking info (blocking).	*/
+#endif
+
+struct flock
+  {
+    short int l_type;   /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence; /* Where `l_start' is relative to (like `lseek').  */
+#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+    __off_t l_start;    /* Offset where the lock begins.  */
+    __off_t l_len;      /* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;  /* Offset where the lock begins.  */
+    __off64_t l_len;    /* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;      /* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;   /* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.  */
+    short int l_whence; /* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;  /* Offset where the lock begins.  */
+    __off64_t l_len;    /* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;      /* Process holding the lock.  */
+  };
+#endif
+
+/* Include generic Linux declarations.  */
+#include <bits/fcntl-linux.h>
--- glibc/sysdeps/unix/sysv/linux/riscv/bits/mman.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/bits/mman.h
@@ -0,0 +1,38 @@
+/* Definitions for POSIX memory map interface.  Linux/MIPS version.
+   Copyright (C) 1997, 2000, 2003, 2004, 2005, 2006, 2009, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+#ifdef __USE_MISC
+# define MAP_GROWSDOWN	0x00100		/* Stack-like segment.  */
+# define MAP_DENYWRITE	0x00800		/* ETXTBSY */
+# define MAP_EXECUTABLE	0x01000		/* Mark it as an executable.  */
+# define MAP_LOCKED	0x02000		/* Lock the mapping.  */
+# define MAP_NORESERVE	0x04000		/* Don't check for reservations.  */
+# define MAP_POPULATE	0x08000		/* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK	0x10000		/* Do not block on IO.  */
+# define MAP_STACK	0x20000		/* Allocation is for a stack.  */
+# define MAP_HUGETLB	0x40000		/* Create huge page mapping.  */
+#endif
+
+/* Include generic Linux declarations.  */
+#include <bits/mman-linux.h>
--- glibc/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/bits/sigcontext.h
@@ -0,0 +1,33 @@
+/* Copyright (C) 1996, 1997, 1998, 2003, 2004, 2006 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H 1
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+struct sigcontext {
+  /* gregs[0] holds the program counter. */
+  unsigned long gregs[32];
+  unsigned long long fpregs[32];
+  unsigned int fsr;
+};
+
+#endif
--- glibc/sysdeps/unix/sysv/linux/riscv/clone.S
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/clone.S
@@ -0,0 +1,106 @@
+/* Copyright (C) 1996, 1997, 2000, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ralf Baechle <ralf@linux-mips.org>, 1996.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* clone() is even more special than fork() as it mucks with stacks
+   and invokes a function in the right context after its all over.  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+#include <tls.h>
+#include "tcb-offsets.h"
+
+#define CLONE_VM      0x00000100
+#define CLONE_THREAD  0x00010000
+
+/* int clone(int (*fn)(void *arg), void *child_stack, int flags, void *arg,
+	     void *parent_tidptr, void *tls, void *child_tidptr) */
+
+	.text
+LEAF(__clone)
+
+	/* Sanity check arguments.  */
+	beqz		a0,L(invalid)	/* No NULL function pointers.  */
+	beqz		a1,L(invalid)	/* No NULL stack pointers.  */
+
+	addi		a1,a1,-32	/* Reserve argument save space.  */
+	REG_S		a0,0(a1)	/* Save function pointer.  */
+	REG_S		a3,SZREG(a1)	/* Save argument pointer.  */
+	REG_S		a2,(SZREG*2)(a1)	/* Save clone flags.  */
+
+	/* The syscall expects the args to be in different slots.  */
+	move		a0,a2
+	move		a2,a4
+	move		a3,a5
+	move		a4,a6
+
+	/* Do the system call */
+	li		a7,__NR_clone
+	scall
+
+	bltz		a0,L(error)
+	beqz		a0,L(thread_start)
+
+	/* Successful return from the parent */
+	ret
+
+L(invalid):
+	li		a0, 0
+	/* Something bad happened -- no child created */
+L(error):
+	j		__syscall_error
+	END(__clone)
+
+/* Load up the arguments to the function.  Put this block of code in
+   its own function so that we can terminate the stack trace with our
+   debug info.  */
+
+ENTRY(__thread_start)
+L(thread_start):
+	/* The stackframe has been created on entry of clone().  */
+
+	/* Check and see if we need to reset the PID.  */
+	li		a1,CLONE_THREAD
+	and		a1,a0,a1
+	beqz		a1,L(restore_pid)
+L(donepid):
+
+	/* Restore the arg for user's function.  */
+	REG_L		a1,0(sp)	/* Function pointer.  */
+	REG_L		a0,SZREG(sp)	/* Argument pointer.  */
+
+	/* Call the user's function.  */
+	jalr		a1
+
+	/* Call _exit with the function's return value.  */
+	j		_exit
+
+L(restore_pid):
+	li		a7,__NR_getpid
+	scall
+L(gotpid):
+	sw		a2,PID_OFFSET(tp)
+	sw		a2,TID_OFFSET(tp)
+	j		L(donepid)
+
+	END(__thread_start)
+
+libc_hidden_def(__clone)
+weak_alias (__clone, clone)
--- glibc/sysdeps/unix/sysv/linux/riscv/configure
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/configure
@@ -0,0 +1,28 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/sysv/linux/riscv.
+
+case "$prefix" in
+/usr | /usr/)
+  # 32-bit libraries on bi-arch platforms go in /lib32 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  riscv/rv32* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.1
+  libc_cv_gcc_unwind_find_fde=no
+fi
--- glibc/sysdeps/unix/sysv/linux/riscv/configure.in
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/configure.in
@@ -0,0 +1,29 @@
+sinclude(./aclocal.m4)dnl Autoconf lossage
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/sysv/linux/riscv.
+
+case "$prefix" in
+/usr | /usr/)
+  # 32-bit libraries on bi-arch platforms go in /lib32 instead of /lib.
+  # Allow earlier configure scripts to handle libc_cv_slibdir, libdir,
+  # and libc_cv_localedir.
+  test -n "$libc_cv_slibdir" || \
+  case $machine in
+  riscv/rv32* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+esac
+
+if test -z "$arch_minimum_kernel"; then
+  arch_minimum_kernel=2.4.1
+  libc_cv_gcc_unwind_find_fde=no
+fi
--- glibc/sysdeps/unix/sysv/linux/riscv/dl-cache.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/dl-cache.h
@@ -0,0 +1,45 @@
+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
+   Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldconfig.h>
+
+#define add_system_dir(dir) \
+  do								\
+    {								\
+      size_t len = strlen (dir);				\
+      char path[len + 3];					\
+      memcpy (path, dir, len + 1);				\
+      if (len >= 6						\
+	  && (! memcmp (path + len - 6, "/lib64", 6)		\
+	      || ! memcmp (path + len - 6, "/lib32", 6)))	\
+	{							\
+	  len -= 2;						\
+	  path[len] = '\0';					\
+	}							\
+      add_dir (path);						\
+      if (len >= 4 && ! memcmp (path + len - 4, "/lib", 4))	\
+	{							\
+	  memcpy (path + len, "32", 3);				\
+	  add_dir (path);					\
+	  memcpy (path + len, "64", 3);				\
+	  add_dir (path);					\
+	}							\
+    } while (0)
+
+#include_next <dl-cache.h>
--- glibc/sysdeps/unix/sysv/linux/riscv/dl-static.c
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/dl-static.c
@@ -0,0 +1,85 @@
+/* Variable initialization.  MIPS version.
+   Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+
+#ifdef SHARED
+
+void
+_dl_var_init (void *array[])
+{
+  /* It has to match "variables" below. */
+  enum
+    {
+      DL_PAGESIZE = 0
+    };
+
+  GLRO(dl_pagesize) = *((size_t *) array[DL_PAGESIZE]);
+}
+
+#else
+
+static void *variables[] =
+{
+  &GLRO(dl_pagesize)
+};
+
+static void
+_dl_unprotect_relro (struct link_map *l)
+{
+  ElfW(Addr) start = ((l->l_addr + l->l_relro_addr)
+		      & ~(GLRO(dl_pagesize) - 1));
+  ElfW(Addr) end = ((l->l_addr + l->l_relro_addr + l->l_relro_size)
+		    & ~(GLRO(dl_pagesize) - 1));
+
+  if (start != end)
+    __mprotect ((void *) start, end - start, PROT_READ | PROT_WRITE);
+}
+
+void
+_dl_static_init (struct link_map *l)
+{
+  struct link_map *rtld_map = l;
+  struct r_scope_elem **scope;
+  const ElfW(Sym) *ref = NULL;
+  lookup_t loadbase;
+  void (*f) (void *[]);
+  size_t i;
+
+  loadbase = _dl_lookup_symbol_x ("_dl_var_init", l, &ref, l->l_local_scope,
+				  NULL, 0, 1, NULL);
+  
+  for (scope = l->l_local_scope; *scope != NULL; scope++)
+    for (i = 0; i < (*scope)->r_nlist; i++)
+      if ((*scope)->r_list[i] == loadbase)
+	{
+	  rtld_map = (*scope)->r_list[i];
+	  break;
+	}
+
+  if (ref != NULL)
+    {
+      f = (void (*) (void *[])) DL_SYMBOL_ADDRESS (loadbase, ref);
+      _dl_unprotect_relro (rtld_map);
+      f (variables);
+      _dl_protect_relro (rtld_map);
+    }
+}
+
+#endif
--- glibc/sysdeps/unix/sysv/linux/riscv/getcontext.S
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/getcontext.S
@@ -0,0 +1,82 @@
+/* Save current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int getcontext (ucontext_t *ucp) */
+
+	.text
+LEAF (__getcontext)
+	REG_S	ra, MCONTEXT_PC(a0)
+	REG_S	ra, ( 1 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	sp, ( 2 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s0, ( 8 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s1, ( 9 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	x0, (10 * SZREG + MCONTEXT_GREGS)(a0)	/* return 0 */
+	REG_S	s2, (18 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s3, (19 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s4, (20 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s5, (21 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s6, (22 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s7, (23 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s8, (24 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s9, (25 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s10,(26 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s11,(27 * SZREG + MCONTEXT_GREGS)(a0)
+
+#ifdef __riscv_hard_float
+	frsr	a1
+
+	fsd	fs0, ( 8 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs1, ( 9 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs2, (18 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs3, (19 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs4, (20 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs5, (21 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs6, (22 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs7, (23 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs8, (24 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs9, (25 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs10,(26 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs11,(27 * 8 + MCONTEXT_FPREGS)(a0)
+
+	sw	a1, MCONTEXT_FSR(a0)
+#endif /* __mips_hard_float */
+
+/* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+	li	a3, _NSIG8
+	add     a2, a0, UCONTEXT_SIGMASK
+	move	a1, zero
+	li	a0, SIG_BLOCK
+
+	li	a7, SYS_ify (rt_sigprocmask)
+	scall
+	bltz	a0, 99f
+
+	ret
+
+99:	j	__syscall_error
+
+PSEUDO_END (__getcontext)
+
+weak_alias (__getcontext, getcontext)
--- glibc/sysdeps/unix/sysv/linux/riscv/getmsg.c
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/getmsg.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/getmsg.c>
--- glibc/sysdeps/unix/sysv/linux/riscv/Implies
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/Implies
@@ -0,0 +1 @@
+riscv/nptl
--- glibc/sysdeps/unix/sysv/linux/riscv/kernel-features.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/kernel-features.h
@@ -0,0 +1,26 @@
+/* Copyright (C) 2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __ASSUME_ACCEPT4_SYSCALL	1
+#define __ASSUME_RECVMMSG_SYSCALL	1
+#define __ASSUME_SENDMMSG_SYSCALL	1
+
+#include_next <kernel-features.h>
+
+/* Define this if your 32-bit syscall API requires 64-bit register
+   pairs to start with an even-number register.  */
+#define __ASSUME_ALIGNED_REGISTER_PAIRS	1
--- glibc/sysdeps/unix/sysv/linux/riscv/ldsodefs.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/ldsodefs.h
@@ -0,0 +1,33 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects. MIPS.
+   Copyright (C) 2001, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LDSODEFS_H
+
+/* Get the real definitions.  */
+#include_next <ldsodefs.h>
+
+/* Now define our stuff.  */
+
+/* We need special support to initialize DSO loaded for statically linked
+   binaries.  */
+extern void _dl_static_init (struct link_map *map);
+#undef DL_STATIC_INIT
+#define DL_STATIC_INIT(map) _dl_static_init (map)
+
+#endif /* ldsodefs.h */
--- glibc/sysdeps/unix/sysv/linux/riscv/libc-abis
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/libc-abis
@@ -0,0 +1,13 @@
+# See the copy of this file in libc for detailed explanations.  This
+# copy needs to include all libc definitions applicable to MIPS; only
+# one copy will be used.
+#
+# Feature Name	Configuration
+# ------------	-------------
+#
+# MIPS PLTs.
+MIPS_PLT	mips*-*-linux*
+#
+# Unique symbol definitions for C++.
+# Architecture independent, all ELF targets (== all targets)
+UNIQUE
--- glibc/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/____longjmp_chk.S
@@ -0,0 +1,2 @@
+#define __longjmp ____longjmp_chk
+#include <__longjmp.S>
--- glibc/sysdeps/unix/sysv/linux/riscv/makecontext.c
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/makecontext.c
@@ -0,0 +1,52 @@
+#include <sysdep.h>
+#include <sys/asm.h>
+#include <sys/ucontext.h>
+#include <stdarg.h>
+#include <assert.h>
+
+void __makecontext (ucontext_t *ucp, void (*func) (void), int argc,
+		    long a0, long a1, long a2, long a3, long a4, ...)
+{
+  extern void __start_context(void) attribute_hidden;
+  long i, sp;
+
+  assert(REG_NARGS == 8);
+
+  /* Set up the stack. */
+  sp = ((long)ucp->uc_stack.ss_sp + ucp->uc_stack.ss_size) & ALMASK;
+
+  /* Set up the register context.
+     ra = s0 = 0, terminating the stack for backtracing purposes.
+     s1 = the function we must call.
+     s2 = the subsequent context to run.  */
+  ucp->uc_mcontext.gregs[REG_RA] = 0;
+  ucp->uc_mcontext.gregs[REG_S0 + 0] = 0;
+  ucp->uc_mcontext.gregs[REG_S0 + 1] = (long)func;
+  ucp->uc_mcontext.gregs[REG_S0 + 2] = (long)ucp->uc_link;
+  ucp->uc_mcontext.gregs[REG_SP] = sp;
+  ucp->uc_mcontext.gregs[REG_PC] = (long)&__start_context;
+
+  /* Put args in a0-a7, then put any remaining args on the stack. */
+  ucp->uc_mcontext.gregs[REG_A0 + 0] = a0;
+  ucp->uc_mcontext.gregs[REG_A0 + 1] = a1;
+  ucp->uc_mcontext.gregs[REG_A0 + 2] = a2;
+  ucp->uc_mcontext.gregs[REG_A0 + 3] = a3;
+  ucp->uc_mcontext.gregs[REG_A0 + 4] = a4;
+
+  if (__builtin_expect (argc > 5, 0))
+    {
+      va_list vl;
+      va_start(vl, a4);
+
+      long reg_args = argc < REG_NARGS ? argc : REG_NARGS;
+      sp = (sp - (argc - reg_args) * sizeof(long)) & ALMASK;
+      for (i = 5; i < reg_args; i++)
+        ucp->uc_mcontext.gregs[REG_A0 + i] = va_arg(vl, long);
+      for (i = 0; i < argc - reg_args; i++)
+        ((long*)sp)[i] = va_arg(vl, long);
+
+      va_end(vl);
+    }
+}
+
+weak_alias (__makecontext, makecontext)
--- glibc/sysdeps/unix/sysv/linux/riscv/Makefile
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/Makefile
@@ -0,0 +1,26 @@
+ifeq ($(subdir),elf)
+ifeq ($(build-shared),yes)
+# This is needed for DSO loading from static binaries.
+sysdep-dl-routines += dl-static
+sysdep_routines += dl-static
+sysdep-rtld-routines += dl-static
+endif
+endif
+
+ifeq ($(subdir),stdlib)
+gen-as-const-headers += ucontext_i.sym
+endif
+
+ifeq ($(subdir),crypt)
+libcrypt-sysdep_routines += sysdep
+endif
+
+ifeq ($(subdir),nss)
+libnss_db-sysdep_routines += sysdep
+libnss_db-shared-only-routines += sysdep
+endif
+
+ifeq ($(subdir),rt)
+librt-sysdep_routines += sysdep
+librt-shared-only-routines += sysdep
+endif
--- glibc/sysdeps/unix/sysv/linux/riscv/profil-counter.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/profil-counter.h
@@ -0,0 +1,2 @@
+/* We can use the ix86 version.  */
+#include <sysdeps/unix/sysv/linux/i386/profil-counter.h>
--- glibc/sysdeps/unix/sysv/linux/riscv/putmsg.c
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/putmsg.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/putmsg.c>
--- glibc/sysdeps/unix/sysv/linux/riscv/register-dump.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/register-dump.h
@@ -0,0 +1,65 @@
+/* Dump registers.
+   Copyright (C) 2000, 2001, 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <string.h>
+#include <_itoa.h>
+
+static void
+hexvalue (unsigned long int value, char *buf, size_t len)
+{
+  char *cp = _itoa_word (value, buf + len, 16, 0);
+  while (cp > buf)
+    *--cp = '0';
+}
+
+#define REGDUMP_NREGS 32
+#define REGDUMP_PER_LINE (80 / (__WORDSIZE/4 + 4))
+
+static void
+register_dump (int fd, struct ucontext *ctx)
+{
+  int i;
+  char regvalue[__WORDSIZE/4 + 1];
+  char str[82 * ((REGDUMP_NREGS + REGDUMP_PER_LINE - 1) / REGDUMP_PER_LINE)];
+
+  static const char names[REGDUMP_NREGS][4] = {
+    "pc", "ra", "sp", "gp", "tp", "t0", "t1", "t2",
+    "s0", "s1", "a0", "a1", "a2", "a3", "a4", "a5",
+    "a6", "a7", "s2", "s3", "s4", "s5", "s6", "s7",
+    "s8", "s9", "sA", "sB", "t3", "t4", "t5", "t6"
+  };
+
+  str[0] = 0;
+  for (i = 0; i < REGDUMP_NREGS; i++)
+    {
+      strcat (str, names[i]);
+      strcat (str, " ");
+      hexvalue (ctx->uc_mcontext.gregs[i], regvalue, __WORDSIZE/4);
+      strcat (str, regvalue);
+
+      if ((i + 1) % REGDUMP_PER_LINE == 0)
+	strcat (str, "\n");
+    }
+
+  write (fd, str, strlen (str));
+}
+
+#define REGISTER_DUMP register_dump (fd, ctx)
--- glibc/sysdeps/unix/sysv/linux/riscv/rv32/Implies
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/rv32/Implies
@@ -0,0 +1,3 @@
+unix/sysv/linux/riscv
+unix/sysv/linux/generic/wordsize-32
+unix/sysv/linux/generic
--- glibc/sysdeps/unix/sysv/linux/riscv/rv32/lockf64.c
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/rv32/lockf64.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/lockf64.c>
--- glibc/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/rv32/readahead.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/arm/readahead.c>
--- glibc/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/rv32/sync_file_range.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/mips/mips32/sync_file_range.c>
--- glibc/sysdeps/unix/sysv/linux/riscv/rv64/Implies
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/rv64/Implies
@@ -0,0 +1,3 @@
+unix/sysv/linux/riscv
+unix/sysv/linux/generic
+unix/sysv/linux/wordsize-64
--- glibc/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/rv64/ldconfig.h
@@ -0,0 +1,26 @@
+/* Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib32/ld.so.1", FLAG_ELF_LIBC6 }, \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.6", FLAG_ELF_LIBC6 },	\
+  { "libm.so.6", FLAG_ELF_LIBC6 },
--- glibc/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/rv64/ldd-rewrite.sed
@@ -0,0 +1 @@
+s_^\(RTLDLIST=\)\(.*lib\)\(\|32\|64\)\(/[^/]*\.so\.[0-9.]*\)[ 	]*$_\1"\232\4 \264\4 \2\4"_
--- glibc/sysdeps/unix/sysv/linux/riscv/rv64/Makefile
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/rv64/Makefile
@@ -0,0 +1,9 @@
+ifeq ($(subdir),socket)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
+
+ifeq ($(subdir),nptl)
+CFLAGS-recv.c += -fexceptions
+CFLAGS-send.c += -fexceptions
+endif
--- glibc/sysdeps/unix/sysv/linux/riscv/setcontext.S
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/setcontext.S
@@ -0,0 +1,126 @@
+/* Set current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+#define RESTORE_FP_REG(name, num, base)			\
+  fld  name, ((num) * 8 + MCONTEXT_FPREGS)(base)
+
+#define RESTORE_FP_REG_CFI(name, num, base)		\
+  RESTORE_FP_REG (name, num, base);			\
+  cfi_offset (name, (num) * SZREG + MCONTEXT_GREGS)
+
+#define RESTORE_INT_REG(name, num, base)		\
+  REG_L name, ((num) * SZREG + MCONTEXT_GREGS)(base)
+
+#define RESTORE_INT_REG_CFI(name, num, base)		\
+  RESTORE_INT_REG (name, num, base);			\
+  cfi_offset (name, (num) * SZREG + MCONTEXT_GREGS)
+
+/* int setcontext (const ucontext_t *ucp) */
+
+	.text
+LEAF (__setcontext)
+
+	mv	t0, a0					/* t0 <- ucp */
+
+/* rt_sigprocmask (SIG_SETMASK, &ucp->uc_sigmask, NULL, _NSIG8) */
+	li	a3, _NSIG8
+	move	a2, zero
+	add     a1, a0, UCONTEXT_SIGMASK
+	li	a0, SIG_SETMASK
+
+	li	a7, SYS_ify (rt_sigprocmask)
+	scall
+
+	bltz	a0, 99f
+
+	cfi_def_cfa (t0, 0)
+
+#ifdef __riscv_hard_float
+	lw	t1, MCONTEXT_FSR(t0)
+
+	RESTORE_FP_REG_CFI (fs0,   8, t0)
+	RESTORE_FP_REG_CFI (fs1,   9, t0)
+	RESTORE_FP_REG_CFI (fs2,  18, t0)
+	RESTORE_FP_REG_CFI (fs3,  19, t0)
+	RESTORE_FP_REG_CFI (fs4,  20, t0)
+	RESTORE_FP_REG_CFI (fs5,  21, t0)
+	RESTORE_FP_REG_CFI (fs6,  22, t0)
+	RESTORE_FP_REG_CFI (fs7,  23, t0)
+	RESTORE_FP_REG_CFI (fs8,  24, t0)
+	RESTORE_FP_REG_CFI (fs9,  25, t0)
+	RESTORE_FP_REG_CFI (fs10, 26, t0)
+	RESTORE_FP_REG_CFI (fs11, 27, t0)
+
+	fssr	t1
+#endif /* __riscv_hard_float */
+
+	/* Note the contents of argument registers will be random
+	   unless makecontext() has been called.  */
+	REG_L	t1, MCONTEXT_PC(t0)
+	RESTORE_INT_REG_CFI (ra,   1, t0)
+	RESTORE_INT_REG     (sp,   2, t0)
+	RESTORE_INT_REG_CFI (s0,   8, t0)
+	RESTORE_INT_REG_CFI (s1,   9, t0)
+	RESTORE_INT_REG     (a0,  10, t0)
+	RESTORE_INT_REG     (a1,  11, t0)
+	RESTORE_INT_REG     (a2,  12, t0)
+	RESTORE_INT_REG     (a3,  13, t0)
+	RESTORE_INT_REG     (a4,  14, t0)
+	RESTORE_INT_REG     (a5,  15, t0)
+	RESTORE_INT_REG     (a6,  16, t0)
+	RESTORE_INT_REG     (a7,  17, t0)
+	RESTORE_INT_REG_CFI (s2,  18, t0)
+	RESTORE_INT_REG_CFI (s3,  19, t0)
+	RESTORE_INT_REG_CFI (s4,  20, t0)
+	RESTORE_INT_REG_CFI (s5,  21, t0)
+	RESTORE_INT_REG_CFI (s6,  22, t0)
+	RESTORE_INT_REG_CFI (s7,  23, t0)
+	RESTORE_INT_REG_CFI (s8,  24, t0)
+	RESTORE_INT_REG_CFI (s9,  25, t0)
+	RESTORE_INT_REG_CFI (s10, 26, t0)
+	RESTORE_INT_REG_CFI (s11, 27, t0)
+
+	jr	t1
+
+99:	j	__syscall_error
+
+PSEUDO_END (__setcontext)
+weak_alias (__setcontext, setcontext)
+
+LEAF (__start_context)
+
+	/* Terminate call stack by noting ra == 0.  Happily, s0 == 0 here.  */
+	cfi_register (ra, s0)
+
+	/* Call the function passed to makecontext.  */
+	jalr	s1
+
+	/* Invoke subsequent context if present, else exit(0).  */
+	mv	a0, s2
+	beqz	s2, 1f
+	jal	__setcontext
+1:	j	exit
+
+PSEUDO_END (__start_context)
--- glibc/sysdeps/unix/sysv/linux/riscv/shlib-versions
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/shlib-versions
@@ -0,0 +1 @@
+DEFAULT		GLIBC_2.20
--- glibc/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/sigcontextinfo.h
@@ -0,0 +1,29 @@
+/* Copyright (C) 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2000.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/ucontext.h>
+
+#define SIGCONTEXT siginfo_t *_si, struct ucontext *
+#define SIGCONTEXT_EXTRA_ARGS _si,
+#define GET_PC(ctx)	((void *) ctx->uc_mcontext.gregs[REG_PC])
+#define GET_FRAME(ctx)	((void *) ctx->uc_mcontext.gregs[REG_S0])
+#define GET_STACK(ctx)	((void *) ctx->uc_mcontext.gregs[REG_SP])
+
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
--- glibc/sysdeps/unix/sysv/linux/riscv/swapcontext.S
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/swapcontext.S
@@ -0,0 +1,130 @@
+/* Save and set current context.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maciej W. Rozycki <macro@codesourcery.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
+   02110-1301, USA.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+#include "ucontext_i.h"
+
+/* int swapcontext (ucontext_t *oucp, const ucontext_t *ucp) */
+
+LEAF (__swapcontext)
+	mv	t0, a1					/* t0 <- ucp */
+
+	REG_S	ra, MCONTEXT_PC(a0)
+	REG_S	ra, ( 1 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	sp, ( 2 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s0, ( 8 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s1, ( 9 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	x0, (10 * SZREG + MCONTEXT_GREGS)(a0)	/* return 0 */
+	REG_S	s2, (18 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s3, (19 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s4, (20 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s5, (21 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s6, (22 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s7, (23 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s8, (24 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s9, (25 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s10,(26 * SZREG + MCONTEXT_GREGS)(a0)
+	REG_S	s11,(27 * SZREG + MCONTEXT_GREGS)(a0)
+
+#ifdef __riscv_hard_float
+	frsr a1
+
+	fsd	fs0, ( 8 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs1, ( 9 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs2, (18 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs3, (19 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs4, (20 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs5, (21 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs6, (22 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs7, (23 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs8, (24 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs9, (25 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs10,(26 * 8 + MCONTEXT_FPREGS)(a0)
+	fsd	fs11,(27 * 8 + MCONTEXT_FPREGS)(a0)
+
+	sw	a1, MCONTEXT_FSR(a0)
+#endif /* __riscv_hard_float */
+
+/* rt_sigprocmask (SIG_SETMASK, &ucp->uc_sigmask, NULL, _NSIG8) */
+	li	a3, _NSIG8
+	move	a2, zero
+	add     a1, a0, UCONTEXT_SIGMASK
+	li	a0, SIG_SETMASK
+
+	li	a7, SYS_ify (rt_sigprocmask)
+	scall
+
+	bltz	a0, 99f
+
+#ifdef __riscv_hard_float
+	lw	t1, MCONTEXT_FSR(t0)
+
+	fld	fs0, ( 8 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs1, ( 9 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs2, (18 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs3, (19 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs4, (20 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs5, (21 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs6, (22 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs7, (23 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs8, (24 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs9, (25 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs10,(26 * 8 + MCONTEXT_FPREGS)(t0)
+	fld	fs11,(27 * 8 + MCONTEXT_FPREGS)(t0)
+
+	fssr	t1
+#endif /* __riscv_hard_float */
+
+	/* Note the contents of argument registers will be random
+	   unless makecontext() has been called.  */
+	REG_L	t1, MCONTEXT_PC(t0)
+	REG_L	ra, ( 1 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	sp, ( 2 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s0, ( 8 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s1, ( 9 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a0, (10 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a1, (11 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a2, (12 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a3, (13 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a4, (14 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a5, (15 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a6, (16 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	a7, (17 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s2, (18 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s3, (19 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s4, (20 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s5, (21 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s6, (22 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s7, (23 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s8, (24 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s9, (25 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s10,(26 * SZREG + MCONTEXT_GREGS)(t0)
+	REG_L	s11,(27 * SZREG + MCONTEXT_GREGS)(t0)
+
+	jr	t1
+
+
+99:	j	__syscall_error
+
+PSEUDO_END (__swapcontext)
+
+weak_alias (__swapcontext, swapcontext)
--- glibc/sysdeps/unix/sysv/linux/riscv/sys/procfs.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/sys/procfs.h
@@ -0,0 +1,113 @@
+/* Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003, 2004
+	Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somehow modelled after the file of the same name on SysVr4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+#include <sys/ucontext.h>
+
+/* ELF register definitions */
+#define ELF_NGREG	NGREG
+#define ELF_NFPREG	NFPREG
+
+typedef greg_t elf_greg_t;
+typedef gregset_t elf_gregset_t;
+typedef fpreg_t elf_fpreg_t;
+typedef fpregset_t elf_fpregset_t;
+
+__BEGIN_DECLS
+
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   gdb doesn't really use excluded.  Fields present but not used are
+   marked with "XXX".  */
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    long pr_uid;
+    long pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore habe only ine PID type.  */
+typedef __pid_t lwpid_t;
+
+
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
--- glibc/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/sys/ucontext.h
@@ -0,0 +1,67 @@
+/* Copyright (C) 1997, 1998, 2000, 2003, 2004, 2006, 2009 Free Software
+   Foundation, Inc.  This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Don't rely on this, the interface is currently messed up and may need to
+   be broken to be fixed.  */
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+/* Type for general register.  Even in o32 we assume 64-bit registers,
+   like the kernel.  */
+__extension__ typedef unsigned long long int greg_t;
+typedef double fpreg_t;
+
+/* Number of general registers.  */
+#define NGREG	32
+#define NFPREG	32
+
+#define REG_PC 0
+#define REG_RA 1
+#define REG_SP 2
+#define REG_TP 4
+#define REG_S0 8
+#define REG_A0 10
+#define REG_NARGS 8
+
+/* Container for all general registers.  */
+typedef greg_t gregset_t[NGREG];
+
+/* Container for all FPU registers.  */
+typedef fpreg_t fpregset_t[NFPREG];
+
+/* Context to describe whole processor state.  */
+typedef struct sigcontext mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long int uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
--- glibc/sysdeps/unix/sysv/linux/riscv/sys/user.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/sys/user.h
@@ -0,0 +1,2 @@
+/* x86 puts "struct user_regs_struct" in here, this is just a shim. */
+#include <asm/ptrace.h>
--- glibc/sysdeps/unix/sysv/linux/riscv/syscall.c
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/syscall.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2001, 2002, 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+long syscall (long syscall_number, long arg1, long arg2, long arg3,
+	      long arg4, long arg5, long arg6, long arg7)
+{
+  long ret;
+  INTERNAL_SYSCALL_DECL (err);
+
+  ret = INTERNAL_SYSCALL_NCS(syscall_number, err, 7, arg1, arg2, arg3, arg4,
+			     arg5, arg6, arg7);
+
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    {
+      extern long __syscall_error (void) attribute_hidden;
+      return __syscall_error();
+    }
+
+  return ret;
+}
--- glibc/sysdeps/unix/sysv/linux/riscv/sysdep.c
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/sysdep.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2015 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andrew Waterman (waterman@cs.berkeley.edu).
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <errno.h>
+
+long __syscall_error(long a0)
+{
+  /* We got here because a0 < 0, but only codes in the range [-4095, -1]
+     represent errors.  Otherwise, just return the result normally.  */
+  if (a0 <= -4096)
+    return a0;
+
+  errno = -a0;
+  return -1;
+}
--- glibc/sysdeps/unix/sysv/linux/riscv/sysdep.h
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/sysdep.h
@@ -0,0 +1,260 @@
+/* Copyright (C) 2011-2014
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LINUX_RISCV_SYSDEP_H
+#define _LINUX_RISCV_SYSDEP_H 1
+
+#include <sysdeps/unix/sysv/linux/generic/sysdep.h>
+#include <tls.h>
+
+#ifdef __ASSEMBLER__
+
+#include <sys/asm.h>
+
+#define ENTRY(name) LEAF(name)
+
+#undef PSEUDO_END
+#define PSEUDO_END(sym) END(sym)
+
+#define PSEUDO_NOERRNO(name, syscall_name, args)	\
+  .align 2;						\
+  ENTRY(name)						\
+  li a7, SYS_ify(syscall_name);				\
+  scall
+
+#define ret_NOERRNO ret
+
+#define PSEUDO_ERRVAL(name, syscall_name, args) \
+  PSEUDO_NOERRNO(name, syscall_name, args)
+
+#define ret_ERRVAL ret
+
+#define r0	a0
+#define r1	a1
+#define MOVE(x,y)	move y , x
+
+#define L(label) .L ## label
+
+#define PSEUDO(name, syscall_name, args) \
+  .align 2;							\
+  99: j __syscall_error;					\
+  ENTRY(name)							\
+  li a7, SYS_ify(syscall_name);					\
+  scall;							\
+  bltz a0, 99b;							\
+L(syse1):
+
+#endif /* __ASSEMBLER__ */
+
+#include <sysdeps/unix/sysdep.h>
+
+#undef SYS_ify
+#define SYS_ify(syscall_name)	__NR_##syscall_name
+
+#ifndef __ASSEMBLER__
+
+/* Define a macro which expands into the inline wrapper code for a system
+   call.  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...)				\
+  ({ INTERNAL_SYSCALL_DECL(err);					\
+     long result_var = INTERNAL_SYSCALL (name, err, nr, args);		\
+     if (result_var < 0)						\
+       {								\
+	 /* __syscall_error handles result_var <= -4096 corner case */	\
+	 extern long __syscall_error (long) attribute_hidden;		\
+	 result_var = __syscall_error (result_var);			\
+       }								\
+     result_var; })
+
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+#define INTERNAL_SYSCALL_ERROR_P(val, err)   ((unsigned long) (val) > -4096UL)
+
+#define INTERNAL_SYSCALL_ERRNO(val, err)     (-val)
+
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+	internal_syscall##nr (SYS_ify (name), err, args)
+
+#define INTERNAL_SYSCALL_NCS(number, err, nr, args...) \
+	internal_syscall##nr (number, err, args)
+
+#define internal_syscall0(number, err, dummy...)			\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __a7 asm("a7") = number;				\
+	register long __a0 asm("a0");					\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "=r" (__a0)							\
+	: "r" (__a7)							\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall1(number, err, arg0)				\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __a7 asm("a7") = number;				\
+	register long __a0 asm("a0") = (long) (arg0);			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__a0)							\
+	: "r" (__a7)							\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall2(number, err, arg0, arg1)	    		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __a7 asm("a7") = number;				\
+	register long __a0 asm("a0") = (long) (arg0);			\
+	register long __a1 asm("a1") = (long) (arg1);			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__a0)							\
+	: "r" (__a7), "r"(__a1)						\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall3(number, err, arg0, arg1, arg2)      		\
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __a7 asm("a7") = number;				\
+	register long __a0 asm("a0") = (long) (arg0);			\
+	register long __a1 asm("a1") = (long) (arg1);			\
+	register long __a2 asm("a2") = (long) (arg2);			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__a0)							\
+	: "r" (__a7), "r"(__a1), "r"(__a2)				\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall4(number, err, arg0, arg1, arg2, arg3)	  \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __a7 asm("a7") = number;				\
+	register long __a0 asm("a0") = (long) (arg0);			\
+	register long __a1 asm("a1") = (long) (arg1);			\
+	register long __a2 asm("a2") = (long) (arg2);			\
+	register long __a3 asm("a3") = (long) (arg3);			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__a0)							\
+	: "r" (__a7), "r"(__a1), "r"(__a2), "r"(__a3)			\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall5(number, err, arg0, arg1, arg2, arg3, arg4)    \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __a7 asm("a7") = number;				\
+	register long __a0 asm("a0") = (long) (arg0);			\
+	register long __a1 asm("a1") = (long) (arg1);			\
+	register long __a2 asm("a2") = (long) (arg2);			\
+	register long __a3 asm("a3") = (long) (arg3);			\
+	register long __a4 asm("a4") = (long) (arg4);			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__a0)							\
+	: "r" (__a7), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4)	\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall6(number, err, arg0, arg1, arg2, arg3, arg4, arg5) \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __a7 asm("a7") = number;				\
+	register long __a0 asm("a0") = (long) (arg0);			\
+	register long __a1 asm("a1") = (long) (arg1);			\
+	register long __a2 asm("a2") = (long) (arg2);			\
+	register long __a3 asm("a3") = (long) (arg3);			\
+	register long __a4 asm("a4") = (long) (arg4);			\
+	register long __a5 asm("a5") = (long) (arg5);			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__a0)							\
+	: "r" (__a7), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4), "r"(__a5)	\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define internal_syscall7(number, err, arg0, arg1, arg2, arg3, arg4, arg5, arg6) \
+({ 									\
+	long _sys_result;						\
+									\
+	{								\
+	register long __a7 asm("a7") = number;				\
+	register long __a0 asm("a0") = (long) (arg0);			\
+	register long __a1 asm("a1") = (long) (arg1);			\
+	register long __a2 asm("a2") = (long) (arg2);			\
+	register long __a3 asm("a3") = (long) (arg3);			\
+	register long __a4 asm("a4") = (long) (arg4);			\
+	register long __a5 asm("a5") = (long) (arg5);			\
+	register long __a6 asm("a6") = (long) (arg6);			\
+	__asm__ volatile ( 						\
+	"scall\n\t" 							\
+	: "+r" (__a0)							\
+	: "r" (__a7), "r"(__a1), "r"(__a2), "r"(__a3), "r"(__a4), "r"(__a5), "r"(__a6)	\
+	: __SYSCALL_CLOBBERS); 						\
+	_sys_result = __a0;						\
+	}								\
+	_sys_result;							\
+})
+
+#define __SYSCALL_CLOBBERS "memory"
+#endif /* ! __ASSEMBLER__ */
+
+/* Pointer mangling is not supported.  */
+#define PTR_MANGLE(var) (void) (var)
+#define PTR_DEMANGLE(var) (void) (var)
+
+#endif /* linux/mips/sysdep.h */
--- glibc/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/ucontext_i.sym
@@ -0,0 +1,33 @@
+#include <inttypes.h>
+#include <signal.h>
+#include <stddef.h>
+#include <sys/ucontext.h>
+
+-- Constants used by the rt_sigprocmask call.
+
+SIG_BLOCK
+SIG_SETMASK
+
+_NSIG8				(_NSIG / 8)
+
+-- Offsets of the fields in the ucontext_t structure.
+#define ucontext(member)	offsetof (ucontext_t, member)
+#define stack(member)		ucontext (uc_stack.member)
+#define mcontext(member)	ucontext (uc_mcontext.member)
+
+UCONTEXT_FLAGS			ucontext (uc_flags)
+UCONTEXT_LINK			ucontext (uc_link)
+UCONTEXT_STACK			ucontext (uc_stack)
+UCONTEXT_MCONTEXT		ucontext (uc_mcontext)
+UCONTEXT_SIGMASK		ucontext (uc_sigmask)
+
+STACK_SP			stack (ss_sp)
+STACK_SIZE			stack (ss_size)
+STACK_FLAGS			stack (ss_flags)
+
+MCONTEXT_GREGS			mcontext (gregs)
+MCONTEXT_FPREGS			mcontext (fpregs)
+MCONTEXT_PC			mcontext (gregs)
+MCONTEXT_FSR			mcontext (fsr)
+
+UCONTEXT_SIZE			sizeof (ucontext_t)
--- glibc/sysdeps/unix/sysv/linux/riscv/Versions
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/Versions
@@ -0,0 +1,40 @@
+ld {
+  GLIBC_PRIVATE {
+    # used for loading by static libraries
+    _dl_var_init;
+  }
+}
+libc {
+  # The comment lines with "#errlist-compat" are magic; see errlist-compat.awk.
+  # When you get an error from errlist-compat.awk, you need to add a new
+  # version here.  Don't do this blindly, since this means changing the ABI
+  # for all GNU/Linux configurations.
+
+  GLIBC_2.0 {
+    #errlist-compat	123
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # Exception handling support functions from libgcc
+    __register_frame; __register_frame_table; __deregister_frame;
+    __frame_state_for; __register_frame_info_table;
+
+    # Needed by gcc:
+    _flush_cache;
+
+    # c*
+    cachectl; cacheflush;
+
+    # s*
+    sysmips;
+  }
+  GLIBC_2.2 {
+    #errlist-compat	1134
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # _*
+    _test_and_set;
+  }
+  GLIBC_2.11 {
+    fallocate64;
+  }
+}
--- glibc/sysdeps/unix/sysv/linux/riscv/vfork.S
+++ riscv-glibc/sysdeps/unix/sysv/linux/riscv/vfork.S
@@ -0,0 +1,69 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* vfork() is just a special case of clone().  */
+
+#include <sys/asm.h>
+#include <sysdep.h>
+#define __ASSEMBLY__
+#include <linux/sched.h>
+#include <asm/signal.h>
+
+#ifndef SAVE_PID
+#define SAVE_PID
+#endif
+
+#ifndef RESTORE_PID
+#define RESTORE_PID
+#endif
+
+
+/* int vfork() */
+
+	.text
+LEAF(__vfork)
+
+	SAVE_PID
+
+#if (CLONE_VFORK | CLONE_VM | SIGCHLD) != 0x4111
+# error
+#endif
+	li		a0, (CLONE_VFORK | CLONE_VM | SIGCHLD)
+	move		a1, sp
+	li		a2, 0
+	li		a3, 0
+	li		a4, 0
+
+	/* Do the system call */
+	li		a7,__NR_clone
+	scall
+
+	bltz		a0,L(error)
+
+	RESTORE_PID
+
+	ret
+
+	/* Something bad happened -- no child created.  */
+L(error):
+	j		__syscall_error
+
+	END(__vfork)
+
+libc_hidden_def(__vfork)
+weak_alias (__vfork, vfork)
